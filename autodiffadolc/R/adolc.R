# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.9
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

##   Generated via the command line invocation:
##	 swig -r -c++ -o adolc_r_wrap.cpp adolc-r.i


#                         srun.swg                            #
#
# This is the basic code that is needed at run time within R to
# provide and define the relevant classes.  It is included
# automatically in the generated code by copying the contents of
# srun.swg into the newly created binding code.


# This could be provided as a separate run-time library but this
# approach allows the code to to be included directly into the
# generated bindings and so removes the need to have and install an
# additional library.  We may however end up with multiple copies of
# this and some confusion at run-time as to which class to use. This
# is an issue when we use NAMESPACES as we may need to export certain
# classes.

######################################################################

if(length(getClassDef("RSWIGStruct")) == 0) 
  setClass("RSWIGStruct", representation("VIRTUAL"))



if(length(getClassDef("ExternalReference")) == 0) 
# Should be virtual but this means it loses its slots currently
#representation("VIRTUAL")
  setClass("ExternalReference", representation( ref = "externalptr"))



if(length(getClassDef("NativeRoutinePointer")) == 0) 
  setClass("NativeRoutinePointer", 
              representation(parameterTypes = "character",
                             returnType = "character",
                             "VIRTUAL"), 
              contains = "ExternalReference")

if(length(getClassDef("CRoutinePointer")) == 0) 
  setClass("CRoutinePointer", contains = "NativeRoutinePointer")


if(length(getClassDef("EnumerationValue")) == 0) 
  setClass("EnumerationValue", contains = "integer")


if(!isGeneric("copyToR")) 
 setGeneric("copyToR",
            function(value, obj = new(gsub("Ref$", "", class(value)))) 
               standardGeneric("copyToR"
           ))

setGeneric("delete", function(obj) standardGeneric("delete"))


SWIG_createNewRef = 
function(className, ..., append = TRUE)
{
  f = get(paste("new", className, sep = "_"), mode = "function")

  f(...)
}

if(!isGeneric("copyToC")) 
 setGeneric("copyToC", 
             function(value, obj = SWIG_createNewRef(class(value)))
              standardGeneric("copyToC"
            ))


# 
defineEnumeration =
function(name, .values, where = topenv(parent.frame()), suffix = "Value")
{
   # Mirror the class definitions via the E analogous to .__C__
  defName = paste(".__E__", name, sep = "")
  assign(defName,  .values,  envir = where)

  if(nchar(suffix))
    name = paste(name, suffix, sep = "")

  setClass(name, contains = "EnumerationValue", where = where)
}

enumToInteger <- function(name,type)
{
   if (is.character(name)) {
   ans <- as.integer(get(paste(".__E__", type, sep = ""))[name])
   if (is.na(ans)) {warning("enum not found ", name, " ", type)}
   ans
   } 
}

enumFromInteger =
function(i,type)
{
  itemlist <- get(paste(".__E__", type, sep=""))
  names(itemlist)[match(i, itemlist)]
}

coerceIfNotSubclass =
function(obj, type) 
{
    if(!is(obj, type)) {as(obj, type)} else obj
}


setClass("SWIGArray", representation(dims = "integer"), contains = "ExternalReference")

setMethod("length", "SWIGArray", function(x) x@dims[1])


defineEnumeration("SCopyReferences",
                   .values = c( "FALSE" = 0, "TRUE" = 1, "DEEP" = 2))

assert = 
function(condition, message = "")
{
  if(!condition)
    stop(message)

  TRUE
}


if(FALSE) {
print.SWIGFunction =
function(x, ...)
 {
 }
}


#######################################################################

R_SWIG_getCallbackFunctionStack =
function()
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_debug_getCallbackFunctionData")
}

R_SWIG_addCallbackFunctionStack =
function(fun, userData = NULL)
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_R_pushCallbackFunctionData", fun, userData)
}


#######################################################################



setClass('C++Reference', contains = 'ExternalReference')
setClass('_p_badouble', contains = 'C++Reference')
setClass('_p_adub', contains = c('_p_badouble'))
setClass('_p_adouble', contains = c('_p_badouble'))
setClass('_p_pdouble', contains = 'C++Reference')
setClass('_p_adubref', contains = 'C++Reference')
setClass('_p_advector', contains = 'C++Reference')
setClass('_p_f_int_p_adouble__int',
        prototype = list(parameterTypes = c('_int', '_p_adouble'),
                        returnType = '_p_f_int_p_adouble__int'),
        contains = 'CRoutinePointer')

##
setClass('_p_f_int_p_double__int',
        prototype = list(parameterTypes = c('_int', '_p_double'),
                        returnType = '_p_f_int_p_double__int'),
        contains = 'CRoutinePointer')

##
setClass('_p_f___p_void',
        prototype = list(parameterTypes = c(),
                        returnType = '_p_f___p_void'),
        contains = 'CRoutinePointer')

##
setClass('_p_f_p_void__void',
        prototype = list(parameterTypes = c('_p_void'),
                        returnType = '_p_f_p_void__void'),
        contains = 'CRoutinePointer')

##
setClass('_p_CP_Context', contains = 'C++Reference')
setClass('_p_f_p_double_p_double_p_double_int_int__int',
        prototype = list(parameterTypes = c('_p_double', '_p_double', '_p_double', '_int', '_int'),
                        returnType = '_p_f_p_double_p_double_p_double_int_int__int'),
        contains = 'CRoutinePointer')

##
setClass('_p_f_p_adouble_p_adouble_p_adouble_int_int__int',
        prototype = list(parameterTypes = c('_p_adouble', '_p_adouble', '_p_adouble', '_int', '_int'),
                        returnType = '_p_f_p_adouble_p_adouble_p_adouble_int_int__int'),
        contains = 'CRoutinePointer')

##
setClass('_p_f_p_double_int__double',
        prototype = list(parameterTypes = c('_p_double', '_int'),
                        returnType = '_p_f_p_double_int__double'),
        contains = 'CRoutinePointer')

##



setMethod('[', "ExternalReference",
function(x,i,j, ..., drop=TRUE) 
if (!is.null(x$"__getitem__")) 
sapply(i, function(n) x$"__getitem__"(i=as.integer(n-1))))

setMethod('[<-' , "ExternalReference",
function(x,i,j, ..., value) 
if (!is.null(x$"__setitem__")) {
sapply(1:length(i), function(n) 
x$"__setitem__"(i=as.integer(i[n]-1), x=value[n]))
x
})

setAs('ExternalReference', 'character',
function(from) {if (!is.null(from$"__str__")) from$"__str__"()})

suppressWarnings(setMethod('print', 'ExternalReference',
#suppressWarnings(setMethod('print', 'externalptr',
function(x) {print(as(x, "character"))}))

# Start of condassign

`condassign__SWIG_0` = function(res, cond, s_arg1, s_arg2)
{
  ;.Call('R_swig_condassign__SWIG_0', res, cond, s_arg1, s_arg2, PACKAGE='autodiffadolc');
  
}

attr(`condassign__SWIG_0`, 'returnType') = 'void'
attr(`condassign__SWIG_0`, "inputTypes") = c('numeric', 'numeric', 'numeric', 'numeric')
class(`condassign__SWIG_0`) = c("SWIGFunction", class('condassign__SWIG_0'))

# Start of condassign

`condassign__SWIG_1` = function(res, cond, s_arg)
{
  ;.Call('R_swig_condassign__SWIG_1', res, cond, s_arg, PACKAGE='autodiffadolc');
  
}

attr(`condassign__SWIG_1`, 'returnType') = 'void'
attr(`condassign__SWIG_1`, "inputTypes") = c('numeric', 'numeric', 'numeric')
class(`condassign__SWIG_1`) = c("SWIGFunction", class('condassign__SWIG_1'))

# Start of condeqassign

`condeqassign__SWIG_0` = function(res, cond, s_arg1, s_arg2)
{
  ;.Call('R_swig_condeqassign__SWIG_0', res, cond, s_arg1, s_arg2, PACKAGE='autodiffadolc');
  
}

attr(`condeqassign__SWIG_0`, 'returnType') = 'void'
attr(`condeqassign__SWIG_0`, "inputTypes") = c('numeric', 'numeric', 'numeric', 'numeric')
class(`condeqassign__SWIG_0`) = c("SWIGFunction", class('condeqassign__SWIG_0'))

# Start of condeqassign

`condeqassign__SWIG_1` = function(res, cond, s_arg)
{
  ;.Call('R_swig_condeqassign__SWIG_1', res, cond, s_arg, PACKAGE='autodiffadolc');
  
}

attr(`condeqassign__SWIG_1`, 'returnType') = 'void'
attr(`condeqassign__SWIG_1`, "inputTypes") = c('numeric', 'numeric', 'numeric')
class(`condeqassign__SWIG_1`) = c("SWIGFunction", class('condeqassign__SWIG_1'))

# Start of badouble_loc

`badouble_loc` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_badouble_loc', self, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_uint32_t", ref=ans);
  
  ans
  
}

attr(`badouble_loc`, 'returnType') = '_p_uint32_t'
attr(`badouble_loc`, "inputTypes") = c('_p_badouble')
class(`badouble_loc`) = c("SWIGFunction", class('badouble_loc'))

# Start of badouble_declareDependent

`badouble_declareDependent__SWIG_0` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;ans = .Call('R_swig_badouble_declareDependent__SWIG_0', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_badouble", ref=ans) ;
  
  ans
  
}

attr(`badouble_declareDependent__SWIG_0`, 'returnType') = '_p_badouble'
attr(`badouble_declareDependent__SWIG_0`, "inputTypes") = c('_p_badouble', 'numeric')
class(`badouble_declareDependent__SWIG_0`) = c("SWIGFunction", class('badouble_declareDependent__SWIG_0'))

# Start of badouble_declareIndependent

`badouble_declareIndependent__SWIG_0` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;ans = .Call('R_swig_badouble_declareIndependent__SWIG_0', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_badouble", ref=ans) ;
  
  ans
  
}

attr(`badouble_declareIndependent__SWIG_0`, 'returnType') = '_p_badouble'
attr(`badouble_declareIndependent__SWIG_0`, "inputTypes") = c('_p_badouble', 'numeric')
class(`badouble_declareIndependent__SWIG_0`) = c("SWIGFunction", class('badouble_declareIndependent__SWIG_0'))

# Start of badouble_declareIndependent

`badouble_declareIndependent__SWIG_1` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_badouble_declareIndependent__SWIG_1', self, PACKAGE='autodiffadolc');
  
}

attr(`badouble_declareIndependent__SWIG_1`, 'returnType') = 'void'
attr(`badouble_declareIndependent__SWIG_1`, "inputTypes") = c('_p_badouble')
class(`badouble_declareIndependent__SWIG_1`) = c("SWIGFunction", class('badouble_declareIndependent__SWIG_1'))

#' Identify independent variables
#'
#' \code{badouble_declareIndependent} identifies the independent variables in the computation. 
#' \code{badouble_declareIndependent} can take a single or multiple arguments. 
#' It is used to identify those input variables that are independents in computation 
#' being differentiated. Derivatives will be computed for identified output 
#' variables (using \code{badouble_declareDependent}) with respect to the 
#' identified input variables.
#'
#' @param variable(s)
#'
#' @return None
#'
#' @examples
#' badouble_declareIndependent(x,z)
#'
#'@seealso{\code{\link{trace_on}}, \code{\link{trace_off}}, 
#'         \code{\link{badouble_declareDependent}}}
#'         
#'@keywords{autodiffadolc}
#'
#' @export

`badouble_declareIndependent` <- function(...) {
    argtypes <- mapply(class, list(...));
    argv <- list(...);
    argc <- length(argtypes);
    # dispatch functions 2
    if (argc == 1) {
        if (extends(argtypes[1], '_p_badouble')) {
            f <- badouble_declareIndependent__SWIG_1;
            return(f(...));
        } else if(is.vector(argv[[1]]) ) {
            loclist <-argv[[1]]
            if(extends(class(loclist[[1]]), '_p_badouble')) {
                f <- badouble_declareIndependent__SWIG_1;
                return(sapply(argv[[1]],f))
            } else {
                stop("cannot find overloaded function for badouble_declareIndependent with argtypes (",toString(argtypes),")");
            }
        } else {
            stop("cannot find overloaded function for badouble_declareIndependent with argtypes (",toString(argtypes),")");
        }
    } else if (argc == 2) {
        if (extends(argtypes[1], '_p_badouble') && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
            f <- badouble_declareIndependent__SWIG_0;
            return(f(...));
        }
    } else {
        stop("cannot find overloaded function for badouble_declareIndependent with argtypes (",toString(argtypes),")");
    };
}

# Dispatch function
# Start of badouble_declareDependent

`badouble_declareDependent__SWIG_1` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_badouble_declareDependent__SWIG_1', self, PACKAGE='autodiffadolc');
  
}

attr(`badouble_declareDependent__SWIG_1`, 'returnType') = 'void'
attr(`badouble_declareDependent__SWIG_1`, "inputTypes") = c('_p_badouble')
class(`badouble_declareDependent__SWIG_1`) = c("SWIGFunction", class('badouble_declareDependent__SWIG_1'))

#' Identify dependent variables
#'
#' \code{badouble_declareDependent} identifies the dependent variables in the computation. 
#' \code{badouble_declareDependent} can take a single or multiple arguments. 
#' It is used to identify those output variables that are dependents in computation 
#' being differentiated. Derivatives will be computed for identified output 
#' variables with respect to the identified input variables 
#' (using \code{badouble_declareIndependent}).
#'
#' @param variable(s)
#'
#' @return None
#'
#' @examples
#' badouble_declareDependent(x,z)
#'
#'@seealso{\code{\link{trace_on}}, \code{\link{trace_off}}, 
#'         \code{\link{badouble_declareIndependent}}}
#'         
#'@keywords{autodiffadolc}
#'
#' @export

`badouble_declareDependent` <- function(...) {
    argtypes <- mapply(class, list(...));
    argv <- list(...);
    argc <- length(argtypes);
    # dispatch functions 2
    if (argc == 1) {
        if(is.list(argv[[1]])){
            return(sapply(argv[[1]],badouble_declareDependent))
        } else if(is.matrix(argv[[1]])){
            return(mapply(argv[1],badouble_declareDependent))
        } else {
            if (extends(argtypes[1], '_p_badouble')) {
                f <- badouble_declareDependent__SWIG_1;
            }
        }
    } else if (argc == 2) {
        if(is.list(argv[[1]])){
            return(sapply(argv[[1]],badouble_declareDependent, argv[[2]]))
        } else if(is.matrix(argv[[1]])){
            return(mapply(argv[1],badouble_declareDependent, argv[[2]]))
        } else {
            if (extends(argtypes[1], '_p_badouble') && is.numeric(argv[[2]]) && length(argv[[2]]) == 1) {
                f <- badouble_declareDependent__SWIG_0;
            }
        }
    } else {
        stop("cannot find overloaded function for badouble_declareDependent with argtypes (",toString(argtypes),")");
    };
    f(...);
}

# Dispatch function
# Start of badouble___seteq__

`badouble___seteq____SWIG_0` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;ans = .Call('R_swig_badouble___seteq____SWIG_0', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_badouble", ref=ans) ;
  
  ans
  
}

attr(`badouble___seteq____SWIG_0`, 'returnType') = '_p_badouble'
attr(`badouble___seteq____SWIG_0`, "inputTypes") = c('_p_badouble', 'numeric')
class(`badouble___seteq____SWIG_0`) = c("SWIGFunction", class('badouble___seteq____SWIG_0'))

# Start of badouble___seteq__

`badouble___seteq____SWIG_1` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_badouble___seteq____SWIG_1', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_badouble", ref=ans) ;
  
  ans
  
}

attr(`badouble___seteq____SWIG_1`, 'returnType') = '_p_badouble'
attr(`badouble___seteq____SWIG_1`, "inputTypes") = c('_p_badouble', '_p_badouble')
class(`badouble___seteq____SWIG_1`) = c("SWIGFunction", class('badouble___seteq____SWIG_1'))

# Start of badouble___seteq__

`badouble___seteq____SWIG_2` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_badouble___seteq____SWIG_2', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_badouble", ref=ans) ;
  
  ans
  
}

attr(`badouble___seteq____SWIG_2`, 'returnType') = '_p_badouble'
attr(`badouble___seteq____SWIG_2`, "inputTypes") = c('_p_badouble', '_p_adub')
class(`badouble___seteq____SWIG_2`) = c("SWIGFunction", class('badouble___seteq____SWIG_2'))

# Start of badouble_getValue

`badouble_getValue` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_badouble_getValue', self, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`badouble_getValue`, 'returnType') = 'numeric'
attr(`badouble_getValue`, "inputTypes") = c('_p_badouble')
class(`badouble_getValue`) = c("SWIGFunction", class('badouble_getValue'))

# Start of badouble_value

`badouble_value` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_badouble_value', self, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`badouble_value`, 'returnType') = 'numeric'
attr(`badouble_value`, "inputTypes") = c('_p_badouble')
class(`badouble_value`) = c("SWIGFunction", class('badouble_value'))

# Start of badouble_setValue

`badouble_setValue` = function(self, s_arg2)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_badouble_setValue', self, s_arg2, PACKAGE='autodiffadolc');
  
}

attr(`badouble_setValue`, 'returnType') = 'void'
attr(`badouble_setValue`, "inputTypes") = c('_p_badouble', 'numeric')
class(`badouble_setValue`) = c("SWIGFunction", class('badouble_setValue'))

# Start of badouble_PlusEqual

`badouble_PlusEqual__SWIG_0` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;ans = .Call('R_swig_badouble_PlusEqual__SWIG_0', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_badouble", ref=ans) ;
  
  ans
  
}

attr(`badouble_PlusEqual__SWIG_0`, 'returnType') = '_p_badouble'
attr(`badouble_PlusEqual__SWIG_0`, "inputTypes") = c('_p_badouble', 'numeric')
class(`badouble_PlusEqual__SWIG_0`) = c("SWIGFunction", class('badouble_PlusEqual__SWIG_0'))

# Start of badouble_PlusEqual

`badouble_PlusEqual__SWIG_1` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_badouble_PlusEqual__SWIG_1', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_badouble", ref=ans) ;
  
  ans
  
}

attr(`badouble_PlusEqual__SWIG_1`, 'returnType') = '_p_badouble'
attr(`badouble_PlusEqual__SWIG_1`, "inputTypes") = c('_p_badouble', '_p_badouble')
class(`badouble_PlusEqual__SWIG_1`) = c("SWIGFunction", class('badouble_PlusEqual__SWIG_1'))

# Start of badouble_MinusEqual

`badouble_MinusEqual__SWIG_0` = function(self, y, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;ans = .Call('R_swig_badouble_MinusEqual__SWIG_0', self, y, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_badouble", ref=ans) ;
  
  ans
  
}

attr(`badouble_MinusEqual__SWIG_0`, 'returnType') = '_p_badouble'
attr(`badouble_MinusEqual__SWIG_0`, "inputTypes") = c('_p_badouble', 'numeric')
class(`badouble_MinusEqual__SWIG_0`) = c("SWIGFunction", class('badouble_MinusEqual__SWIG_0'))

# Start of badouble_MinusEqual

`badouble_MinusEqual__SWIG_1` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_badouble_MinusEqual__SWIG_1', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_badouble", ref=ans) ;
  
  ans
  
}

attr(`badouble_MinusEqual__SWIG_1`, 'returnType') = '_p_badouble'
attr(`badouble_MinusEqual__SWIG_1`, "inputTypes") = c('_p_badouble', '_p_badouble')
class(`badouble_MinusEqual__SWIG_1`) = c("SWIGFunction", class('badouble_MinusEqual__SWIG_1'))

# Start of badouble_MultiplyEqual

`badouble_MultiplyEqual__SWIG_0` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;ans = .Call('R_swig_badouble_MultiplyEqual__SWIG_0', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_badouble", ref=ans) ;
  
  ans
  
}

attr(`badouble_MultiplyEqual__SWIG_0`, 'returnType') = '_p_badouble'
attr(`badouble_MultiplyEqual__SWIG_0`, "inputTypes") = c('_p_badouble', 'numeric')
class(`badouble_MultiplyEqual__SWIG_0`) = c("SWIGFunction", class('badouble_MultiplyEqual__SWIG_0'))

# Start of badouble_MultiplyEqual

`badouble_MultiplyEqual__SWIG_1` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_badouble_MultiplyEqual__SWIG_1', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_badouble", ref=ans) ;
  
  ans
  
}

attr(`badouble_MultiplyEqual__SWIG_1`, 'returnType') = '_p_badouble'
attr(`badouble_MultiplyEqual__SWIG_1`, "inputTypes") = c('_p_badouble', '_p_badouble')
class(`badouble_MultiplyEqual__SWIG_1`) = c("SWIGFunction", class('badouble_MultiplyEqual__SWIG_1'))

# Start of badouble_DivideEqual

`badouble_DivideEqual__SWIG_0` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;ans = .Call('R_swig_badouble_DivideEqual__SWIG_0', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_badouble", ref=ans) ;
  
  ans
  
}

attr(`badouble_DivideEqual__SWIG_0`, 'returnType') = '_p_badouble'
attr(`badouble_DivideEqual__SWIG_0`, "inputTypes") = c('_p_badouble', 'numeric')
class(`badouble_DivideEqual__SWIG_0`) = c("SWIGFunction", class('badouble_DivideEqual__SWIG_0'))

# Start of badouble_DivideEqual

`badouble_DivideEqual__SWIG_1` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_badouble_DivideEqual__SWIG_1', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_badouble", ref=ans) ;
  
  ans
  
}

attr(`badouble_DivideEqual__SWIG_1`, 'returnType') = '_p_badouble'
attr(`badouble_DivideEqual__SWIG_1`, "inputTypes") = c('_p_badouble', '_p_badouble')
class(`badouble_DivideEqual__SWIG_1`) = c("SWIGFunction", class('badouble_DivideEqual__SWIG_1'))

# Start of badouble_PlusEqual

`badouble_PlusEqual__SWIG_2` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_badouble_PlusEqual__SWIG_2', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_badouble", ref=ans) ;
  
  ans
  
}

attr(`badouble_PlusEqual__SWIG_2`, 'returnType') = '_p_badouble'
attr(`badouble_PlusEqual__SWIG_2`, "inputTypes") = c('_p_badouble', '_p_adub')
class(`badouble_PlusEqual__SWIG_2`) = c("SWIGFunction", class('badouble_PlusEqual__SWIG_2'))

# Start of badouble_MinusEqual

`badouble_MinusEqual__SWIG_2` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_badouble_MinusEqual__SWIG_2', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_badouble", ref=ans) ;
  
  ans
  
}

attr(`badouble_MinusEqual__SWIG_2`, 'returnType') = '_p_badouble'
attr(`badouble_MinusEqual__SWIG_2`, "inputTypes") = c('_p_badouble', '_p_adub')
class(`badouble_MinusEqual__SWIG_2`) = c("SWIGFunction", class('badouble_MinusEqual__SWIG_2'))

# Start of badouble___seteq__

`badouble___seteq____SWIG_3` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_badouble___seteq____SWIG_3', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_badouble", ref=ans) ;
  
  ans
  
}

attr(`badouble___seteq____SWIG_3`, 'returnType') = '_p_badouble'
attr(`badouble___seteq____SWIG_3`, "inputTypes") = c('_p_badouble', '_p_pdouble')
class(`badouble___seteq____SWIG_3`) = c("SWIGFunction", class('badouble___seteq____SWIG_3'))

`badouble___seteq__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 2) {
    if (extends(argtypes[1], '_p_badouble') && extends(argtypes[2], '_p_adub') && length(argv[[2]]) == 1) {
      f <- badouble___seteq____SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_badouble') && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- badouble___seteq____SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_badouble') && extends(argtypes[2], '_p_pdouble') && length(argv[[2]]) == 1) {
      f <- badouble___seteq____SWIG_3; 
    }
    else if (extends(argtypes[1], '_p_badouble') && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- badouble___seteq____SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for badouble___seteq__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of badouble_PlusEqual

`badouble_PlusEqual__SWIG_3` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_badouble_PlusEqual__SWIG_3', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_badouble", ref=ans) ;
  
  ans
  
}

attr(`badouble_PlusEqual__SWIG_3`, 'returnType') = '_p_badouble'
attr(`badouble_PlusEqual__SWIG_3`, "inputTypes") = c('_p_badouble', '_p_pdouble')
class(`badouble_PlusEqual__SWIG_3`) = c("SWIGFunction", class('badouble_PlusEqual__SWIG_3'))

`badouble_PlusEqual` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 2) {
    if (extends(argtypes[1], '_p_badouble') && extends(argtypes[2], '_p_adub') && length(argv[[2]]) == 1) {
      f <- badouble_PlusEqual__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_badouble') && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- badouble_PlusEqual__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_badouble') && extends(argtypes[2], '_p_pdouble') && length(argv[[2]]) == 1) {
      f <- badouble_PlusEqual__SWIG_3; 
    }
    else if (extends(argtypes[1], '_p_badouble') && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- badouble_PlusEqual__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for badouble_PlusEqual with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of badouble_MinusEqual

`badouble_MinusEqual__SWIG_3` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_badouble_MinusEqual__SWIG_3', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_badouble", ref=ans) ;
  
  ans
  
}

attr(`badouble_MinusEqual__SWIG_3`, 'returnType') = '_p_badouble'
attr(`badouble_MinusEqual__SWIG_3`, "inputTypes") = c('_p_badouble', '_p_pdouble')
class(`badouble_MinusEqual__SWIG_3`) = c("SWIGFunction", class('badouble_MinusEqual__SWIG_3'))

`badouble_MinusEqual` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 2) {
    if (extends(argtypes[1], '_p_badouble') && extends(argtypes[2], '_p_adub') && length(argv[[2]]) == 1) {
      f <- badouble_MinusEqual__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_badouble') && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- badouble_MinusEqual__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_badouble') && extends(argtypes[2], '_p_pdouble') && length(argv[[2]]) == 1) {
      f <- badouble_MinusEqual__SWIG_3; 
    }
    else if (extends(argtypes[1], '_p_badouble') && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- badouble_MinusEqual__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for badouble_MinusEqual with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of badouble_MultiplyEqual

`badouble_MultiplyEqual__SWIG_2` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_badouble_MultiplyEqual__SWIG_2', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_badouble", ref=ans) ;
  
  ans
  
}

attr(`badouble_MultiplyEqual__SWIG_2`, 'returnType') = '_p_badouble'
attr(`badouble_MultiplyEqual__SWIG_2`, "inputTypes") = c('_p_badouble', '_p_pdouble')
class(`badouble_MultiplyEqual__SWIG_2`) = c("SWIGFunction", class('badouble_MultiplyEqual__SWIG_2'))

`badouble_MultiplyEqual` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 2) {
    if (extends(argtypes[1], '_p_badouble') && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- badouble_MultiplyEqual__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_badouble') && extends(argtypes[2], '_p_pdouble') && length(argv[[2]]) == 1) {
      f <- badouble_MultiplyEqual__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_badouble') && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- badouble_MultiplyEqual__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for badouble_MultiplyEqual with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of badouble_DivideEqual

`badouble_DivideEqual__SWIG_2` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_badouble_DivideEqual__SWIG_2', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_badouble", ref=ans) ;
  
  ans
  
}

attr(`badouble_DivideEqual__SWIG_2`, 'returnType') = '_p_badouble'
attr(`badouble_DivideEqual__SWIG_2`, "inputTypes") = c('_p_badouble', '_p_pdouble')
class(`badouble_DivideEqual__SWIG_2`) = c("SWIGFunction", class('badouble_DivideEqual__SWIG_2'))

`badouble_DivideEqual` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 2) {
    if (extends(argtypes[1], '_p_badouble') && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- badouble_DivideEqual__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_badouble') && extends(argtypes[2], '_p_pdouble') && length(argv[[2]]) == 1) {
      f <- badouble_DivideEqual__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_badouble') && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- badouble_DivideEqual__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for badouble_DivideEqual with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of NotEqual

`NotEqual__SWIG_0` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;.Call('R_swig_NotEqual__SWIG_0', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`NotEqual__SWIG_0`, 'returnType') = 'integer'
attr(`NotEqual__SWIG_0`, "inputTypes") = c('_p_badouble', '_p_badouble')
class(`NotEqual__SWIG_0`) = c("SWIGFunction", class('NotEqual__SWIG_0'))

# Start of EqualEqual

`EqualEqual__SWIG_0` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;.Call('R_swig_EqualEqual__SWIG_0', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`EqualEqual__SWIG_0`, 'returnType') = 'integer'
attr(`EqualEqual__SWIG_0`, "inputTypes") = c('_p_badouble', '_p_badouble')
class(`EqualEqual__SWIG_0`) = c("SWIGFunction", class('EqualEqual__SWIG_0'))

# Start of LessThanEqual

`LessThanEqual__SWIG_0` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;.Call('R_swig_LessThanEqual__SWIG_0', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`LessThanEqual__SWIG_0`, 'returnType') = 'integer'
attr(`LessThanEqual__SWIG_0`, "inputTypes") = c('_p_badouble', '_p_badouble')
class(`LessThanEqual__SWIG_0`) = c("SWIGFunction", class('LessThanEqual__SWIG_0'))

# Start of GreaterThanEqual

`GreaterThanEqual__SWIG_0` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;.Call('R_swig_GreaterThanEqual__SWIG_0', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`GreaterThanEqual__SWIG_0`, 'returnType') = 'integer'
attr(`GreaterThanEqual__SWIG_0`, "inputTypes") = c('_p_badouble', '_p_badouble')
class(`GreaterThanEqual__SWIG_0`) = c("SWIGFunction", class('GreaterThanEqual__SWIG_0'))

# Start of GreaterThan

`GreaterThan__SWIG_0` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;.Call('R_swig_GreaterThan__SWIG_0', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`GreaterThan__SWIG_0`, 'returnType') = 'integer'
attr(`GreaterThan__SWIG_0`, "inputTypes") = c('_p_badouble', '_p_badouble')
class(`GreaterThan__SWIG_0`) = c("SWIGFunction", class('GreaterThan__SWIG_0'))

# Start of LessThan

`LessThan__SWIG_0` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;.Call('R_swig_LessThan__SWIG_0', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`LessThan__SWIG_0`, 'returnType') = 'integer'
attr(`LessThan__SWIG_0`, "inputTypes") = c('_p_badouble', '_p_badouble')
class(`LessThan__SWIG_0`) = c("SWIGFunction", class('LessThan__SWIG_0'))

# Start of NotEqual

`NotEqual__SWIG_1` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;.Call('R_swig_NotEqual__SWIG_1', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`NotEqual__SWIG_1`, 'returnType') = 'integer'
attr(`NotEqual__SWIG_1`, "inputTypes") = c('numeric', '_p_badouble')
class(`NotEqual__SWIG_1`) = c("SWIGFunction", class('NotEqual__SWIG_1'))

# Start of NotEqual

`NotEqual__SWIG_2` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  
  ;.Call('R_swig_NotEqual__SWIG_2', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`NotEqual__SWIG_2`, 'returnType') = 'integer'
attr(`NotEqual__SWIG_2`, "inputTypes") = c('_p_badouble', 'numeric')
class(`NotEqual__SWIG_2`) = c("SWIGFunction", class('NotEqual__SWIG_2'))

# Start of EqualEqual

`EqualEqual__SWIG_1` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;.Call('R_swig_EqualEqual__SWIG_1', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`EqualEqual__SWIG_1`, 'returnType') = 'integer'
attr(`EqualEqual__SWIG_1`, "inputTypes") = c('numeric', '_p_badouble')
class(`EqualEqual__SWIG_1`) = c("SWIGFunction", class('EqualEqual__SWIG_1'))

# Start of EqualEqual

`EqualEqual__SWIG_2` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  
  ;.Call('R_swig_EqualEqual__SWIG_2', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`EqualEqual__SWIG_2`, 'returnType') = 'integer'
attr(`EqualEqual__SWIG_2`, "inputTypes") = c('_p_badouble', 'numeric')
class(`EqualEqual__SWIG_2`) = c("SWIGFunction", class('EqualEqual__SWIG_2'))

# Start of LessThanEqual

`LessThanEqual__SWIG_1` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;.Call('R_swig_LessThanEqual__SWIG_1', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`LessThanEqual__SWIG_1`, 'returnType') = 'integer'
attr(`LessThanEqual__SWIG_1`, "inputTypes") = c('numeric', '_p_badouble')
class(`LessThanEqual__SWIG_1`) = c("SWIGFunction", class('LessThanEqual__SWIG_1'))

# Start of LessThanEqual

`LessThanEqual__SWIG_2` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  
  ;.Call('R_swig_LessThanEqual__SWIG_2', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`LessThanEqual__SWIG_2`, 'returnType') = 'integer'
attr(`LessThanEqual__SWIG_2`, "inputTypes") = c('_p_badouble', 'numeric')
class(`LessThanEqual__SWIG_2`) = c("SWIGFunction", class('LessThanEqual__SWIG_2'))

# Start of GreaterThanEqual

`GreaterThanEqual__SWIG_1` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;.Call('R_swig_GreaterThanEqual__SWIG_1', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`GreaterThanEqual__SWIG_1`, 'returnType') = 'integer'
attr(`GreaterThanEqual__SWIG_1`, "inputTypes") = c('numeric', '_p_badouble')
class(`GreaterThanEqual__SWIG_1`) = c("SWIGFunction", class('GreaterThanEqual__SWIG_1'))

# Start of GreaterThanEqual

`GreaterThanEqual__SWIG_2` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  
  ;.Call('R_swig_GreaterThanEqual__SWIG_2', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`GreaterThanEqual__SWIG_2`, 'returnType') = 'integer'
attr(`GreaterThanEqual__SWIG_2`, "inputTypes") = c('_p_badouble', 'numeric')
class(`GreaterThanEqual__SWIG_2`) = c("SWIGFunction", class('GreaterThanEqual__SWIG_2'))

# Start of GreaterThan

`GreaterThan__SWIG_1` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;.Call('R_swig_GreaterThan__SWIG_1', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`GreaterThan__SWIG_1`, 'returnType') = 'integer'
attr(`GreaterThan__SWIG_1`, "inputTypes") = c('numeric', '_p_badouble')
class(`GreaterThan__SWIG_1`) = c("SWIGFunction", class('GreaterThan__SWIG_1'))

# Start of GreaterThan

`GreaterThan__SWIG_2` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  
  ;.Call('R_swig_GreaterThan__SWIG_2', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`GreaterThan__SWIG_2`, 'returnType') = 'integer'
attr(`GreaterThan__SWIG_2`, "inputTypes") = c('_p_badouble', 'numeric')
class(`GreaterThan__SWIG_2`) = c("SWIGFunction", class('GreaterThan__SWIG_2'))

# Start of LessThan

`LessThan__SWIG_1` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;.Call('R_swig_LessThan__SWIG_1', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`LessThan__SWIG_1`, 'returnType') = 'integer'
attr(`LessThan__SWIG_1`, "inputTypes") = c('numeric', '_p_badouble')
class(`LessThan__SWIG_1`) = c("SWIGFunction", class('LessThan__SWIG_1'))

# Start of LessThan

`LessThan__SWIG_2` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  
  ;.Call('R_swig_LessThan__SWIG_2', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`LessThan__SWIG_2`, 'returnType') = 'integer'
attr(`LessThan__SWIG_2`, "inputTypes") = c('_p_badouble', 'numeric')
class(`LessThan__SWIG_2`) = c("SWIGFunction", class('LessThan__SWIG_2'))

# Start of atan2

`atan2` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_atan2', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adouble", ref=ans);
  
  ans
  
}

attr(`atan2`, 'returnType') = '_p_adouble'
attr(`atan2`, "inputTypes") = c('_p_badouble', '_p_badouble')
class(`atan2`) = c("SWIGFunction", class('atan2'))

# Start of pow

`pow__SWIG_0` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_pow__SWIG_0', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adouble", ref=ans);
  
  ans
  
}

attr(`pow__SWIG_0`, 'returnType') = '_p_adouble'
attr(`pow__SWIG_0`, "inputTypes") = c('_p_badouble', '_p_badouble')
class(`pow__SWIG_0`) = c("SWIGFunction", class('pow__SWIG_0'))

# Start of pow

`pow__SWIG_1` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_pow__SWIG_1', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adouble", ref=ans);
  
  ans
  
}

attr(`pow__SWIG_1`, 'returnType') = '_p_adouble'
attr(`pow__SWIG_1`, "inputTypes") = c('numeric', '_p_badouble')
class(`pow__SWIG_1`) = c("SWIGFunction", class('pow__SWIG_1'))

# Start of myquad

`myquad` = function(s_arg1, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_myquad', s_arg1, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adouble", ref=ans);
  
  ans
  
}

attr(`myquad`, 'returnType') = '_p_adouble'
attr(`myquad`, "inputTypes") = c('_p_badouble')
class(`myquad`) = c("SWIGFunction", class('myquad'))

# Start of condassign

`condassign__SWIG_2` = function(res, cond, s_arg1, s_arg2)
{
  if (inherits(res, "ExternalReference")) res = slot(res,"ref") 
  if (inherits(cond, "ExternalReference")) cond = slot(cond,"ref") 
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;.Call('R_swig_condassign__SWIG_2', res, cond, s_arg1, s_arg2, PACKAGE='autodiffadolc');
  
}

attr(`condassign__SWIG_2`, 'returnType') = 'void'
attr(`condassign__SWIG_2`, "inputTypes") = c('_p_adouble', '_p_badouble', '_p_badouble', '_p_badouble')
class(`condassign__SWIG_2`) = c("SWIGFunction", class('condassign__SWIG_2'))

# Start of condassign

`condassign__SWIG_3` = function(res, cond, s_arg)
{
  if (inherits(res, "ExternalReference")) res = slot(res,"ref") 
  if (inherits(cond, "ExternalReference")) cond = slot(cond,"ref") 
  if (inherits(s_arg, "ExternalReference")) s_arg = slot(s_arg,"ref") 
  ;.Call('R_swig_condassign__SWIG_3', res, cond, s_arg, PACKAGE='autodiffadolc');
  
}

attr(`condassign__SWIG_3`, 'returnType') = 'void'
attr(`condassign__SWIG_3`, "inputTypes") = c('_p_adouble', '_p_badouble', '_p_badouble')
class(`condassign__SWIG_3`) = c("SWIGFunction", class('condassign__SWIG_3'))

# Start of condeqassign

`condeqassign__SWIG_2` = function(res, cond, s_arg1, s_arg2)
{
  if (inherits(res, "ExternalReference")) res = slot(res,"ref") 
  if (inherits(cond, "ExternalReference")) cond = slot(cond,"ref") 
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;.Call('R_swig_condeqassign__SWIG_2', res, cond, s_arg1, s_arg2, PACKAGE='autodiffadolc');
  
}

attr(`condeqassign__SWIG_2`, 'returnType') = 'void'
attr(`condeqassign__SWIG_2`, "inputTypes") = c('_p_adouble', '_p_badouble', '_p_badouble', '_p_badouble')
class(`condeqassign__SWIG_2`) = c("SWIGFunction", class('condeqassign__SWIG_2'))

# Start of condeqassign

`condeqassign__SWIG_3` = function(res, cond, s_arg)
{
  if (inherits(res, "ExternalReference")) res = slot(res,"ref") 
  if (inherits(cond, "ExternalReference")) cond = slot(cond,"ref") 
  if (inherits(s_arg, "ExternalReference")) s_arg = slot(s_arg,"ref") 
  ;.Call('R_swig_condeqassign__SWIG_3', res, cond, s_arg, PACKAGE='autodiffadolc');
  
}

attr(`condeqassign__SWIG_3`, 'returnType') = 'void'
attr(`condeqassign__SWIG_3`, "inputTypes") = c('_p_adouble', '_p_badouble', '_p_badouble')
class(`condeqassign__SWIG_3`) = c("SWIGFunction", class('condeqassign__SWIG_3'))

# Start of NotEqual

`NotEqual__SWIG_3` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;.Call('R_swig_NotEqual__SWIG_3', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`NotEqual__SWIG_3`, 'returnType') = 'integer'
attr(`NotEqual__SWIG_3`, "inputTypes") = c('_p_pdouble', '_p_badouble')
class(`NotEqual__SWIG_3`) = c("SWIGFunction", class('NotEqual__SWIG_3'))

# Start of NotEqual

`NotEqual__SWIG_4` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;.Call('R_swig_NotEqual__SWIG_4', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`NotEqual__SWIG_4`, 'returnType') = 'integer'
attr(`NotEqual__SWIG_4`, "inputTypes") = c('_p_badouble', '_p_pdouble')
class(`NotEqual__SWIG_4`) = c("SWIGFunction", class('NotEqual__SWIG_4'))

`NotEqual` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 5
  if (argc == 2) {
    if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- NotEqual__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_pdouble') && length(argv[[2]]) == 1) {
      f <- NotEqual__SWIG_4; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- NotEqual__SWIG_3; 
    }
    else if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1 && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- NotEqual__SWIG_2; 
    }
    else if (( is.numeric(argv[[1]]) && length(argv[[1]]) == 1 ) && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- NotEqual__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for NotEqual with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of EqualEqual

`EqualEqual__SWIG_3` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;.Call('R_swig_EqualEqual__SWIG_3', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`EqualEqual__SWIG_3`, 'returnType') = 'integer'
attr(`EqualEqual__SWIG_3`, "inputTypes") = c('_p_pdouble', '_p_badouble')
class(`EqualEqual__SWIG_3`) = c("SWIGFunction", class('EqualEqual__SWIG_3'))

# Start of EqualEqual

`EqualEqual__SWIG_4` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;.Call('R_swig_EqualEqual__SWIG_4', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`EqualEqual__SWIG_4`, 'returnType') = 'integer'
attr(`EqualEqual__SWIG_4`, "inputTypes") = c('_p_badouble', '_p_pdouble')
class(`EqualEqual__SWIG_4`) = c("SWIGFunction", class('EqualEqual__SWIG_4'))

`EqualEqual` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 5
  if (argc == 2) {
    if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- EqualEqual__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_pdouble') && length(argv[[2]]) == 1) {
      f <- EqualEqual__SWIG_4; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- EqualEqual__SWIG_3; 
    }
    else if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1 && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- EqualEqual__SWIG_2; 
    }
    else if (( is.numeric(argv[[1]]) && length(argv[[1]]) == 1 ) && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- EqualEqual__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for EqualEqual with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of LessThanEqual

`LessThanEqual__SWIG_3` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;.Call('R_swig_LessThanEqual__SWIG_3', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`LessThanEqual__SWIG_3`, 'returnType') = 'integer'
attr(`LessThanEqual__SWIG_3`, "inputTypes") = c('_p_pdouble', '_p_badouble')
class(`LessThanEqual__SWIG_3`) = c("SWIGFunction", class('LessThanEqual__SWIG_3'))

# Start of LessThanEqual

`LessThanEqual__SWIG_4` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;.Call('R_swig_LessThanEqual__SWIG_4', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`LessThanEqual__SWIG_4`, 'returnType') = 'integer'
attr(`LessThanEqual__SWIG_4`, "inputTypes") = c('_p_badouble', '_p_pdouble')
class(`LessThanEqual__SWIG_4`) = c("SWIGFunction", class('LessThanEqual__SWIG_4'))

`LessThanEqual` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 5
  if (argc == 2) {
    if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- LessThanEqual__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_pdouble') && length(argv[[2]]) == 1) {
      f <- LessThanEqual__SWIG_4; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- LessThanEqual__SWIG_3; 
    }
    else if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1 && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- LessThanEqual__SWIG_2; 
    }
    else if (( is.numeric(argv[[1]]) && length(argv[[1]]) == 1 ) && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- LessThanEqual__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for LessThanEqual with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of GreaterThanEqual

`GreaterThanEqual__SWIG_3` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;.Call('R_swig_GreaterThanEqual__SWIG_3', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`GreaterThanEqual__SWIG_3`, 'returnType') = 'integer'
attr(`GreaterThanEqual__SWIG_3`, "inputTypes") = c('_p_pdouble', '_p_badouble')
class(`GreaterThanEqual__SWIG_3`) = c("SWIGFunction", class('GreaterThanEqual__SWIG_3'))

# Start of GreaterThanEqual

`GreaterThanEqual__SWIG_4` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;.Call('R_swig_GreaterThanEqual__SWIG_4', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`GreaterThanEqual__SWIG_4`, 'returnType') = 'integer'
attr(`GreaterThanEqual__SWIG_4`, "inputTypes") = c('_p_badouble', '_p_pdouble')
class(`GreaterThanEqual__SWIG_4`) = c("SWIGFunction", class('GreaterThanEqual__SWIG_4'))

`GreaterThanEqual` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 5
  if (argc == 2) {
    if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- GreaterThanEqual__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_pdouble') && length(argv[[2]]) == 1) {
      f <- GreaterThanEqual__SWIG_4; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- GreaterThanEqual__SWIG_3; 
    }
    else if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1 && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- GreaterThanEqual__SWIG_2; 
    }
    else if (( is.numeric(argv[[1]]) && length(argv[[1]]) == 1 ) && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- GreaterThanEqual__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for GreaterThanEqual with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of GreaterThan

`GreaterThan__SWIG_3` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;.Call('R_swig_GreaterThan__SWIG_3', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`GreaterThan__SWIG_3`, 'returnType') = 'integer'
attr(`GreaterThan__SWIG_3`, "inputTypes") = c('_p_pdouble', '_p_badouble')
class(`GreaterThan__SWIG_3`) = c("SWIGFunction", class('GreaterThan__SWIG_3'))

# Start of GreaterThan

`GreaterThan__SWIG_4` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;.Call('R_swig_GreaterThan__SWIG_4', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`GreaterThan__SWIG_4`, 'returnType') = 'integer'
attr(`GreaterThan__SWIG_4`, "inputTypes") = c('_p_badouble', '_p_pdouble')
class(`GreaterThan__SWIG_4`) = c("SWIGFunction", class('GreaterThan__SWIG_4'))

`GreaterThan` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 5
  if (argc == 2) {
    if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- GreaterThan__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_pdouble') && length(argv[[2]]) == 1) {
      f <- GreaterThan__SWIG_4; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- GreaterThan__SWIG_3; 
    }
    else if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1 && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- GreaterThan__SWIG_2; 
    }
    else if (( is.numeric(argv[[1]]) && length(argv[[1]]) == 1 ) && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- GreaterThan__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for GreaterThan with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of LessThan

`LessThan__SWIG_3` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;.Call('R_swig_LessThan__SWIG_3', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`LessThan__SWIG_3`, 'returnType') = 'integer'
attr(`LessThan__SWIG_3`, "inputTypes") = c('_p_pdouble', '_p_badouble')
class(`LessThan__SWIG_3`) = c("SWIGFunction", class('LessThan__SWIG_3'))

# Start of LessThan

`LessThan__SWIG_4` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;.Call('R_swig_LessThan__SWIG_4', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`LessThan__SWIG_4`, 'returnType') = 'integer'
attr(`LessThan__SWIG_4`, "inputTypes") = c('_p_badouble', '_p_pdouble')
class(`LessThan__SWIG_4`) = c("SWIGFunction", class('LessThan__SWIG_4'))

`LessThan` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 5
  if (argc == 2) {
    if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- LessThan__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_pdouble') && length(argv[[2]]) == 1) {
      f <- LessThan__SWIG_4; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- LessThan__SWIG_3; 
    }
    else if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1 && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- LessThan__SWIG_2; 
    }
    else if (( is.numeric(argv[[1]]) && length(argv[[1]]) == 1 ) && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- LessThan__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for LessThan with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of pow

`pow__SWIG_2` = function(s_arg1, s_arg2, .copy = FALSE)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_pow__SWIG_2', s_arg1, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adouble", ref=ans);
  
  ans
  
}

attr(`pow__SWIG_2`, 'returnType') = '_p_adouble'
attr(`pow__SWIG_2`, "inputTypes") = c('_p_pdouble', '_p_badouble')
class(`pow__SWIG_2`) = c("SWIGFunction", class('pow__SWIG_2'))

# Start of delete_badouble

`delete_badouble` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_badouble', self, PACKAGE='autodiffadolc');
  
}

attr(`delete_badouble`, 'returnType') = 'void'
attr(`delete_badouble`, "inputTypes") = c('_p_badouble')
class(`delete_badouble`) = c("SWIGFunction", class('delete_badouble'))

# Start of accessor method for badouble
setMethod('$', '_p_badouble', function(x, name)

{
  accessorFuns = list('loc' = badouble_loc, 'declareDependent' = badouble_declareDependent, 'declareIndependent' = badouble_declareIndependent, '__seteq__' = badouble___seteq__, 'getValue' = badouble_getValue, 'value' = badouble_value, 'setValue' = badouble_setValue, 'PlusEqual' = badouble_PlusEqual, 'MinusEqual' = badouble_MinusEqual, 'MultiplyEqual' = badouble_MultiplyEqual, 'DivideEqual' = badouble_DivideEqual);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for badouble
setMethod('delete', '_p_badouble', function(obj) {delete_badouble(obj)})
# Start of delete_adub

`delete_adub` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_adub', self, PACKAGE='autodiffadolc');
  
}

attr(`delete_adub`, 'returnType') = 'void'
attr(`delete_adub`, "inputTypes") = c('_p_adub')
class(`delete_adub`) = c("SWIGFunction", class('delete_adub'))

setMethod('delete', '_p_adub', function(obj) {delete_adub(obj)})
# Start of ensureContiguousLocations

`ensureContiguousLocations` = function(n)
{
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_ensureContiguousLocations', n, PACKAGE='autodiffadolc');
  
}

attr(`ensureContiguousLocations`, 'returnType') = 'void'
attr(`ensureContiguousLocations`, "inputTypes") = c('integer')
class(`ensureContiguousLocations`) = c("SWIGFunction", class('ensureContiguousLocations'))

# Start of new_adouble

`adouble__SWIG_0` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_new_adouble__SWIG_0', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adouble", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_adouble)
  ans
  
}

attr(`adouble__SWIG_0`, 'returnType') = '_p_adouble'
attr(`adouble__SWIG_0`, "inputTypes") = c('_p_adub')
class(`adouble__SWIG_0`) = c("SWIGFunction", class('adouble__SWIG_0'))

# Start of new_adouble

`adouble__SWIG_1` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_new_adouble__SWIG_1', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adouble", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_adouble)
  ans
  
}

attr(`adouble__SWIG_1`, 'returnType') = '_p_adouble'
attr(`adouble__SWIG_1`, "inputTypes") = c('_p_adouble')
class(`adouble__SWIG_1`) = c("SWIGFunction", class('adouble__SWIG_1'))

# Start of new_adouble

`adouble__SWIG_2` = function()
{
  ;ans = .Call('R_swig_new_adouble__SWIG_2', PACKAGE='autodiffadolc');
  ans <- new("_p_adouble", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_adouble)
  ans
  
}

attr(`adouble__SWIG_2`, 'returnType') = '_p_adouble'
class(`adouble__SWIG_2`) = c("SWIGFunction", class('adouble__SWIG_2'))

# Start of new_adouble

`adouble__SWIG_3` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_adouble__SWIG_3', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adouble", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_adouble)
  ans
  
}

attr(`adouble__SWIG_3`, 'returnType') = '_p_adouble'
attr(`adouble__SWIG_3`, "inputTypes") = c('numeric')
class(`adouble__SWIG_3`) = c("SWIGFunction", class('adouble__SWIG_3'))

`adouble` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- adouble__SWIG_2; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_adouble') && length(argv[[1]]) == 1) {
      f <- adouble__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_adub') && length(argv[[1]]) == 1) {
      f <- adouble__SWIG_0; 
    }
    else if (( is.numeric(argv[[1]]) && length(argv[[1]]) == 1 )) {
      f <- adouble__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for adouble with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of adouble___plusplus__

`adouble___plusplus____SWIG_0` = function(self, s_arg2)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  ;ans = .Call('R_swig_adouble___plusplus____SWIG_0', self, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`adouble___plusplus____SWIG_0`, 'returnType') = '_p_adub'
attr(`adouble___plusplus____SWIG_0`, "inputTypes") = c('_p_adouble', 'integer')
class(`adouble___plusplus____SWIG_0`) = c("SWIGFunction", class('adouble___plusplus____SWIG_0'))

# Start of adouble___minusminus__

`adouble___minusminus____SWIG_0` = function(self, s_arg2)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  ;ans = .Call('R_swig_adouble___minusminus____SWIG_0', self, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`adouble___minusminus____SWIG_0`, 'returnType') = '_p_adub'
attr(`adouble___minusminus____SWIG_0`, "inputTypes") = c('_p_adouble', 'integer')
class(`adouble___minusminus____SWIG_0`) = c("SWIGFunction", class('adouble___minusminus____SWIG_0'))

# Start of adouble___plusplus__

`adouble___plusplus____SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_adouble___plusplus____SWIG_1', self, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_badouble", ref=ans) ;
  
  ans
  
}

attr(`adouble___plusplus____SWIG_1`, 'returnType') = '_p_badouble'
attr(`adouble___plusplus____SWIG_1`, "inputTypes") = c('_p_adouble')
class(`adouble___plusplus____SWIG_1`) = c("SWIGFunction", class('adouble___plusplus____SWIG_1'))

`adouble___plusplus__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_adouble')) {
      f <- adouble___plusplus____SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_adouble') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- adouble___plusplus____SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for adouble___plusplus__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of adouble___minusminus__

`adouble___minusminus____SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_adouble___minusminus____SWIG_1', self, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_badouble", ref=ans) ;
  
  ans
  
}

attr(`adouble___minusminus____SWIG_1`, 'returnType') = '_p_badouble'
attr(`adouble___minusminus____SWIG_1`, "inputTypes") = c('_p_adouble')
class(`adouble___minusminus____SWIG_1`) = c("SWIGFunction", class('adouble___minusminus____SWIG_1'))

`adouble___minusminus__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_adouble')) {
      f <- adouble___minusminus____SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_adouble') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- adouble___minusminus____SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for adouble___minusminus__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_adouble

`delete_adouble` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_adouble', self, PACKAGE='autodiffadolc');
  
}

attr(`delete_adouble`, 'returnType') = 'void'
attr(`delete_adouble`, "inputTypes") = c('_p_adouble')
class(`delete_adouble`) = c("SWIGFunction", class('delete_adouble'))

# Start of adouble___seteq__

`adouble___seteq____SWIG_0` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;ans = .Call('R_swig_adouble___seteq____SWIG_0', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adouble", ref=ans) ;
  
  ans
  
}

attr(`adouble___seteq____SWIG_0`, 'returnType') = '_p_adouble'
attr(`adouble___seteq____SWIG_0`, "inputTypes") = c('_p_adouble', 'numeric')
class(`adouble___seteq____SWIG_0`) = c("SWIGFunction", class('adouble___seteq____SWIG_0'))

# Start of adouble___seteq__

`adouble___seteq____SWIG_1` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_adouble___seteq____SWIG_1', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adouble", ref=ans) ;
  
  ans
  
}

attr(`adouble___seteq____SWIG_1`, 'returnType') = '_p_adouble'
attr(`adouble___seteq____SWIG_1`, "inputTypes") = c('_p_adouble', '_p_badouble')
class(`adouble___seteq____SWIG_1`) = c("SWIGFunction", class('adouble___seteq____SWIG_1'))

# Start of adouble___seteq__

`adouble___seteq____SWIG_2` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_adouble___seteq____SWIG_2', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adouble", ref=ans) ;
  
  ans
  
}

attr(`adouble___seteq____SWIG_2`, 'returnType') = '_p_adouble'
attr(`adouble___seteq____SWIG_2`, "inputTypes") = c('_p_adouble', '_p_adouble')
class(`adouble___seteq____SWIG_2`) = c("SWIGFunction", class('adouble___seteq____SWIG_2'))

# Start of adouble___seteq__

`adouble___seteq____SWIG_3` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_adouble___seteq____SWIG_3', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adouble", ref=ans) ;
  
  ans
  
}

attr(`adouble___seteq____SWIG_3`, 'returnType') = '_p_adouble'
attr(`adouble___seteq____SWIG_3`, "inputTypes") = c('_p_adouble', '_p_adub')
class(`adouble___seteq____SWIG_3`) = c("SWIGFunction", class('adouble___seteq____SWIG_3'))

# Start of adouble___seteq__

`adouble___seteq____SWIG_4` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_adouble___seteq____SWIG_4', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adouble", ref=ans) ;
  
  ans
  
}

attr(`adouble___seteq____SWIG_4`, 'returnType') = '_p_adouble'
attr(`adouble___seteq____SWIG_4`, "inputTypes") = c('_p_adouble', '_p_pdouble')
class(`adouble___seteq____SWIG_4`) = c("SWIGFunction", class('adouble___seteq____SWIG_4'))

`adouble___seteq__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 5
  if (argc == 2) {
    if (extends(argtypes[1], '_p_adouble') && extends(argtypes[2], '_p_adouble') && length(argv[[2]]) == 1) {
      f <- adouble___seteq____SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_adouble') && extends(argtypes[2], '_p_adub') && length(argv[[2]]) == 1) {
      f <- adouble___seteq____SWIG_3; 
    }
    else if (extends(argtypes[1], '_p_adouble') && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- adouble___seteq____SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_adouble') && extends(argtypes[2], '_p_pdouble') && length(argv[[2]]) == 1) {
      f <- adouble___seteq____SWIG_4; 
    }
    else if (extends(argtypes[1], '_p_adouble') && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- adouble___seteq____SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for adouble___seteq__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of adouble_loc

`adouble_loc` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_adouble_loc', self, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_uint32_t", ref=ans);
  
  ans
  
}

attr(`adouble_loc`, 'returnType') = '_p_uint32_t'
attr(`adouble_loc`, "inputTypes") = c('_p_adouble')
class(`adouble_loc`) = c("SWIGFunction", class('adouble_loc'))

# Start of accessor method for adouble
setMethod('$', '_p_adouble', function(x, name)

{
  accessorFuns = list('__plusplus__' = adouble___plusplus__, '__minusminus__' = adouble___minusminus__, '__seteq__' = adouble___seteq__, 'loc' = adouble_loc);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for adouble
setMethod('delete', '_p_adouble', function(obj) {delete_adouble(obj)})
# Start of mkparam_idx

`mkparam_idx` = function(pval, .copy = FALSE)
{
  ;ans = .Call('R_swig_mkparam_idx', pval, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_uint32_t", ref=ans);
  
  ans
  
}

attr(`mkparam_idx`, 'returnType') = '_p_uint32_t'
attr(`mkparam_idx`, "inputTypes") = c('numeric')
class(`mkparam_idx`) = c("SWIGFunction", class('mkparam_idx'))

# Start of delete_pdouble

`delete_pdouble` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_pdouble', self, PACKAGE='autodiffadolc');
  
}

attr(`delete_pdouble`, 'returnType') = 'void'
attr(`delete_pdouble`, "inputTypes") = c('_p_pdouble')
class(`delete_pdouble`) = c("SWIGFunction", class('delete_pdouble'))

setMethod('delete', '_p_pdouble', function(obj) {delete_pdouble(obj)})
# Start of get_num_param

`get_num_param` = function(tag, .copy = FALSE)
{
  tag = as.integer(tag);
  
  if(length(tag) > 1) {
    warning("using only the first element of tag");
  };
  
  ;.Call('R_swig_get_num_param', tag, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`get_num_param`, 'returnType') = 'integer'
attr(`get_num_param`, "inputTypes") = c('integer')
class(`get_num_param`) = c("SWIGFunction", class('get_num_param'))

# Start of set_param_vec

`set_param_vec` = function(tag, numparam, paramvec)
{
  tag = as.integer(tag);
  
  if(length(tag) > 1) {
    warning("using only the first element of tag");
  };
  
  numparam = as.integer(numparam);
  
  if(length(numparam) > 1) {
    warning("using only the first element of numparam");
  };
  
  
  ;.Call('R_swig_set_param_vec', tag, numparam, paramvec, PACKAGE='autodiffadolc');
  
}

attr(`set_param_vec`, 'returnType') = 'void'
attr(`set_param_vec`, "inputTypes") = c('integer', 'integer', 'numeric')
class(`set_param_vec`) = c("SWIGFunction", class('set_param_vec'))

# Start of adubref___plusplus__

`adubref___plusplus____SWIG_0` = function(self, s_arg2)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  ;ans = .Call('R_swig_adubref___plusplus____SWIG_0', self, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`adubref___plusplus____SWIG_0`, 'returnType') = '_p_adub'
attr(`adubref___plusplus____SWIG_0`, "inputTypes") = c('_p_adubref', 'integer')
class(`adubref___plusplus____SWIG_0`) = c("SWIGFunction", class('adubref___plusplus____SWIG_0'))

# Start of adubref___minusminus__

`adubref___minusminus____SWIG_0` = function(self, s_arg2)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  ;ans = .Call('R_swig_adubref___minusminus____SWIG_0', self, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`adubref___minusminus____SWIG_0`, 'returnType') = '_p_adub'
attr(`adubref___minusminus____SWIG_0`, "inputTypes") = c('_p_adubref', 'integer')
class(`adubref___minusminus____SWIG_0`) = c("SWIGFunction", class('adubref___minusminus____SWIG_0'))

# Start of adubref___plusplus__

`adubref___plusplus____SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_adubref___plusplus____SWIG_1', self, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adubref", ref=ans) ;
  
  ans
  
}

attr(`adubref___plusplus____SWIG_1`, 'returnType') = '_p_adubref'
attr(`adubref___plusplus____SWIG_1`, "inputTypes") = c('_p_adubref')
class(`adubref___plusplus____SWIG_1`) = c("SWIGFunction", class('adubref___plusplus____SWIG_1'))

`adubref___plusplus__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_adubref')) {
      f <- adubref___plusplus____SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_adubref') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- adubref___plusplus____SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for adubref___plusplus__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of adubref___minusminus__

`adubref___minusminus____SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_adubref___minusminus____SWIG_1', self, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adubref", ref=ans) ;
  
  ans
  
}

attr(`adubref___minusminus____SWIG_1`, 'returnType') = '_p_adubref'
attr(`adubref___minusminus____SWIG_1`, "inputTypes") = c('_p_adubref')
class(`adubref___minusminus____SWIG_1`) = c("SWIGFunction", class('adubref___minusminus____SWIG_1'))

`adubref___minusminus__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_adubref')) {
      f <- adubref___minusminus____SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_adubref') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- adubref___minusminus____SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for adubref___minusminus__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of adubref___seteq__

`adubref___seteq____SWIG_0` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;ans = .Call('R_swig_adubref___seteq____SWIG_0', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adubref", ref=ans) ;
  
  ans
  
}

attr(`adubref___seteq____SWIG_0`, 'returnType') = '_p_adubref'
attr(`adubref___seteq____SWIG_0`, "inputTypes") = c('_p_adubref', 'numeric')
class(`adubref___seteq____SWIG_0`) = c("SWIGFunction", class('adubref___seteq____SWIG_0'))

# Start of adubref___seteq__

`adubref___seteq____SWIG_1` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_adubref___seteq____SWIG_1', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adubref", ref=ans) ;
  
  ans
  
}

attr(`adubref___seteq____SWIG_1`, 'returnType') = '_p_adubref'
attr(`adubref___seteq____SWIG_1`, "inputTypes") = c('_p_adubref', '_p_badouble')
class(`adubref___seteq____SWIG_1`) = c("SWIGFunction", class('adubref___seteq____SWIG_1'))

# Start of adubref___seteq__

`adubref___seteq____SWIG_2` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_adubref___seteq____SWIG_2', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adubref", ref=ans) ;
  
  ans
  
}

attr(`adubref___seteq____SWIG_2`, 'returnType') = '_p_adubref'
attr(`adubref___seteq____SWIG_2`, "inputTypes") = c('_p_adubref', '_p_adubref')
class(`adubref___seteq____SWIG_2`) = c("SWIGFunction", class('adubref___seteq____SWIG_2'))

# Start of adubref___seteq__

`adubref___seteq____SWIG_3` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_adubref___seteq____SWIG_3', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adubref", ref=ans) ;
  
  ans
  
}

attr(`adubref___seteq____SWIG_3`, 'returnType') = '_p_adubref'
attr(`adubref___seteq____SWIG_3`, "inputTypes") = c('_p_adubref', '_p_pdouble')
class(`adubref___seteq____SWIG_3`) = c("SWIGFunction", class('adubref___seteq____SWIG_3'))

`adubref___seteq__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 2) {
    if (extends(argtypes[1], '_p_adubref') && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- adubref___seteq____SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_adubref') && extends(argtypes[2], '_p_adubref') && length(argv[[2]]) == 1) {
      f <- adubref___seteq____SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_adubref') && extends(argtypes[2], '_p_pdouble') && length(argv[[2]]) == 1) {
      f <- adubref___seteq____SWIG_3; 
    }
    else if (extends(argtypes[1], '_p_adubref') && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- adubref___seteq____SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for adubref___seteq__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of adubref_PlusEqual

`adubref_PlusEqual__SWIG_0` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;ans = .Call('R_swig_adubref_PlusEqual__SWIG_0', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adubref", ref=ans) ;
  
  ans
  
}

attr(`adubref_PlusEqual__SWIG_0`, 'returnType') = '_p_adubref'
attr(`adubref_PlusEqual__SWIG_0`, "inputTypes") = c('_p_adubref', 'numeric')
class(`adubref_PlusEqual__SWIG_0`) = c("SWIGFunction", class('adubref_PlusEqual__SWIG_0'))

# Start of adubref_PlusEqual

`adubref_PlusEqual__SWIG_1` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_adubref_PlusEqual__SWIG_1', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adubref", ref=ans) ;
  
  ans
  
}

attr(`adubref_PlusEqual__SWIG_1`, 'returnType') = '_p_adubref'
attr(`adubref_PlusEqual__SWIG_1`, "inputTypes") = c('_p_adubref', '_p_badouble')
class(`adubref_PlusEqual__SWIG_1`) = c("SWIGFunction", class('adubref_PlusEqual__SWIG_1'))

# Start of adubref_PlusEqual

`adubref_PlusEqual__SWIG_2` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_adubref_PlusEqual__SWIG_2', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adubref", ref=ans) ;
  
  ans
  
}

attr(`adubref_PlusEqual__SWIG_2`, 'returnType') = '_p_adubref'
attr(`adubref_PlusEqual__SWIG_2`, "inputTypes") = c('_p_adubref', '_p_pdouble')
class(`adubref_PlusEqual__SWIG_2`) = c("SWIGFunction", class('adubref_PlusEqual__SWIG_2'))

`adubref_PlusEqual` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 2) {
    if (extends(argtypes[1], '_p_adubref') && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- adubref_PlusEqual__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_adubref') && extends(argtypes[2], '_p_pdouble') && length(argv[[2]]) == 1) {
      f <- adubref_PlusEqual__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_adubref') && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- adubref_PlusEqual__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for adubref_PlusEqual with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of adubref_MinusEqual

`adubref_MinusEqual__SWIG_0` = function(self, x, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;ans = .Call('R_swig_adubref_MinusEqual__SWIG_0', self, x, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adubref", ref=ans) ;
  
  ans
  
}

attr(`adubref_MinusEqual__SWIG_0`, 'returnType') = '_p_adubref'
attr(`adubref_MinusEqual__SWIG_0`, "inputTypes") = c('_p_adubref', 'numeric')
class(`adubref_MinusEqual__SWIG_0`) = c("SWIGFunction", class('adubref_MinusEqual__SWIG_0'))

# Start of adubref_MinusEqual

`adubref_MinusEqual__SWIG_1` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_adubref_MinusEqual__SWIG_1', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adubref", ref=ans) ;
  
  ans
  
}

attr(`adubref_MinusEqual__SWIG_1`, 'returnType') = '_p_adubref'
attr(`adubref_MinusEqual__SWIG_1`, "inputTypes") = c('_p_adubref', '_p_badouble')
class(`adubref_MinusEqual__SWIG_1`) = c("SWIGFunction", class('adubref_MinusEqual__SWIG_1'))

# Start of adubref_MinusEqual

`adubref_MinusEqual__SWIG_2` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_adubref_MinusEqual__SWIG_2', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adubref", ref=ans) ;
  
  ans
  
}

attr(`adubref_MinusEqual__SWIG_2`, 'returnType') = '_p_adubref'
attr(`adubref_MinusEqual__SWIG_2`, "inputTypes") = c('_p_adubref', '_p_pdouble')
class(`adubref_MinusEqual__SWIG_2`) = c("SWIGFunction", class('adubref_MinusEqual__SWIG_2'))

`adubref_MinusEqual` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 2) {
    if (extends(argtypes[1], '_p_adubref') && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- adubref_MinusEqual__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_adubref') && extends(argtypes[2], '_p_pdouble') && length(argv[[2]]) == 1) {
      f <- adubref_MinusEqual__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_adubref') && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- adubref_MinusEqual__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for adubref_MinusEqual with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of adubref_MultiplyEqual

`adubref_MultiplyEqual__SWIG_0` = function(self, x, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;ans = .Call('R_swig_adubref_MultiplyEqual__SWIG_0', self, x, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adubref", ref=ans) ;
  
  ans
  
}

attr(`adubref_MultiplyEqual__SWIG_0`, 'returnType') = '_p_adubref'
attr(`adubref_MultiplyEqual__SWIG_0`, "inputTypes") = c('_p_adubref', 'numeric')
class(`adubref_MultiplyEqual__SWIG_0`) = c("SWIGFunction", class('adubref_MultiplyEqual__SWIG_0'))

# Start of adubref_MultiplyEqual

`adubref_MultiplyEqual__SWIG_1` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_adubref_MultiplyEqual__SWIG_1', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adubref", ref=ans) ;
  
  ans
  
}

attr(`adubref_MultiplyEqual__SWIG_1`, 'returnType') = '_p_adubref'
attr(`adubref_MultiplyEqual__SWIG_1`, "inputTypes") = c('_p_adubref', '_p_badouble')
class(`adubref_MultiplyEqual__SWIG_1`) = c("SWIGFunction", class('adubref_MultiplyEqual__SWIG_1'))

# Start of adubref_MultiplyEqual

`adubref_MultiplyEqual__SWIG_2` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_adubref_MultiplyEqual__SWIG_2', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adubref", ref=ans) ;
  
  ans
  
}

attr(`adubref_MultiplyEqual__SWIG_2`, 'returnType') = '_p_adubref'
attr(`adubref_MultiplyEqual__SWIG_2`, "inputTypes") = c('_p_adubref', '_p_pdouble')
class(`adubref_MultiplyEqual__SWIG_2`) = c("SWIGFunction", class('adubref_MultiplyEqual__SWIG_2'))

`adubref_MultiplyEqual` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 2) {
    if (extends(argtypes[1], '_p_adubref') && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- adubref_MultiplyEqual__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_adubref') && extends(argtypes[2], '_p_pdouble') && length(argv[[2]]) == 1) {
      f <- adubref_MultiplyEqual__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_adubref') && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- adubref_MultiplyEqual__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for adubref_MultiplyEqual with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of adubref_DivideEqual

`adubref_DivideEqual__SWIG_0` = function(self, x, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;ans = .Call('R_swig_adubref_DivideEqual__SWIG_0', self, x, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adubref", ref=ans) ;
  
  ans
  
}

attr(`adubref_DivideEqual__SWIG_0`, 'returnType') = '_p_adubref'
attr(`adubref_DivideEqual__SWIG_0`, "inputTypes") = c('_p_adubref', 'numeric')
class(`adubref_DivideEqual__SWIG_0`) = c("SWIGFunction", class('adubref_DivideEqual__SWIG_0'))

# Start of adubref_DivideEqual

`adubref_DivideEqual__SWIG_1` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_adubref_DivideEqual__SWIG_1', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adubref", ref=ans) ;
  
  ans
  
}

attr(`adubref_DivideEqual__SWIG_1`, 'returnType') = '_p_adubref'
attr(`adubref_DivideEqual__SWIG_1`, "inputTypes") = c('_p_adubref', '_p_badouble')
class(`adubref_DivideEqual__SWIG_1`) = c("SWIGFunction", class('adubref_DivideEqual__SWIG_1'))

# Start of adubref_DivideEqual

`adubref_DivideEqual__SWIG_2` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_adubref_DivideEqual__SWIG_2', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adubref", ref=ans) ;
  
  ans
  
}

attr(`adubref_DivideEqual__SWIG_2`, 'returnType') = '_p_adubref'
attr(`adubref_DivideEqual__SWIG_2`, "inputTypes") = c('_p_adubref', '_p_pdouble')
class(`adubref_DivideEqual__SWIG_2`) = c("SWIGFunction", class('adubref_DivideEqual__SWIG_2'))

`adubref_DivideEqual` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 2) {
    if (extends(argtypes[1], '_p_adubref') && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- adubref_DivideEqual__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_adubref') && extends(argtypes[2], '_p_pdouble') && length(argv[[2]]) == 1) {
      f <- adubref_DivideEqual__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_adubref') && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- adubref_DivideEqual__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for adubref_DivideEqual with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of adubref_declareIndependent

`adubref_declareIndependent__SWIG_0` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;ans = .Call('R_swig_adubref_declareIndependent__SWIG_0', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adubref", ref=ans) ;
  
  ans
  
}

attr(`adubref_declareIndependent__SWIG_0`, 'returnType') = '_p_adubref'
attr(`adubref_declareIndependent__SWIG_0`, "inputTypes") = c('_p_adubref', 'numeric')
class(`adubref_declareIndependent__SWIG_0`) = c("SWIGFunction", class('adubref_declareIndependent__SWIG_0'))

# Start of adubref_declareIndependent

`adubref_declareIndependent__SWIG_1` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_adubref_declareIndependent__SWIG_1', self, PACKAGE='autodiffadolc');
  
}

attr(`adubref_declareIndependent__SWIG_1`, 'returnType') = 'void'
attr(`adubref_declareIndependent__SWIG_1`, "inputTypes") = c('_p_adubref')
class(`adubref_declareIndependent__SWIG_1`) = c("SWIGFunction", class('adubref_declareIndependent__SWIG_1'))

`adubref_declareIndependent` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_adubref')) {
      f <- adubref_declareIndependent__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_adubref') && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- adubref_declareIndependent__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for adubref_declareIndependent with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of adubref_declareDependent

`adubref_declareDependent__SWIG_0` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;ans = .Call('R_swig_adubref_declareDependent__SWIG_0', self, s_arg2, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adubref", ref=ans) ;
  
  ans
  
}

attr(`adubref_declareDependent__SWIG_0`, 'returnType') = '_p_adubref'
attr(`adubref_declareDependent__SWIG_0`, "inputTypes") = c('_p_adubref', 'numeric')
class(`adubref_declareDependent__SWIG_0`) = c("SWIGFunction", class('adubref_declareDependent__SWIG_0'))

# Start of adubref_declareDependent

`adubref_declareDependent__SWIG_1` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_adubref_declareDependent__SWIG_1', self, PACKAGE='autodiffadolc');
  
}

attr(`adubref_declareDependent__SWIG_1`, 'returnType') = 'void'
attr(`adubref_declareDependent__SWIG_1`, "inputTypes") = c('_p_adubref')
class(`adubref_declareDependent__SWIG_1`) = c("SWIGFunction", class('adubref_declareDependent__SWIG_1'))

`adubref_declareDependent` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_adubref')) {
      f <- adubref_declareDependent__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_adubref') && is.numeric(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- adubref_declareDependent__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for adubref_declareDependent with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of condassign

`condassign__SWIG_4` = function(s_arg1, s_arg2, s_arg3, s_arg4)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  if (inherits(s_arg3, "ExternalReference")) s_arg3 = slot(s_arg3,"ref") 
  if (inherits(s_arg4, "ExternalReference")) s_arg4 = slot(s_arg4,"ref") 
  ;.Call('R_swig_condassign__SWIG_4', s_arg1, s_arg2, s_arg3, s_arg4, PACKAGE='autodiffadolc');
  
}

attr(`condassign__SWIG_4`, 'returnType') = 'void'
attr(`condassign__SWIG_4`, "inputTypes") = c('_p_adubref', '_p_badouble', '_p_badouble', '_p_badouble')
class(`condassign__SWIG_4`) = c("SWIGFunction", class('condassign__SWIG_4'))

# Start of condassign

`condassign__SWIG_5` = function(s_arg1, s_arg2, s_arg3)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  if (inherits(s_arg3, "ExternalReference")) s_arg3 = slot(s_arg3,"ref") 
  ;.Call('R_swig_condassign__SWIG_5', s_arg1, s_arg2, s_arg3, PACKAGE='autodiffadolc');
  
}

attr(`condassign__SWIG_5`, 'returnType') = 'void'
attr(`condassign__SWIG_5`, "inputTypes") = c('_p_adubref', '_p_badouble', '_p_badouble')
class(`condassign__SWIG_5`) = c("SWIGFunction", class('condassign__SWIG_5'))

`condassign` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 6
  if (argc == 3) {
    if (is.numeric(argv[[1]]) && length(argv[[1]]) == 1 && is.numeric(argv[[2]]) && length(argv[[2]]) == 1 && is.numeric(argv[[3]]) && length(argv[[3]]) == 1) {
      f <- condassign__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_adouble') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1 && extends(argtypes[3], '_p_badouble') && length(argv[[3]]) == 1) {
      f <- condassign__SWIG_3; 
    }
    else if (extends(argtypes[1], '_p_adubref') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1 && extends(argtypes[3], '_p_badouble') && length(argv[[3]]) == 1) {
      f <- condassign__SWIG_5; 
    }
  } else if (argc == 4) {
    if (is.numeric(argv[[1]]) && length(argv[[1]]) == 1 && is.numeric(argv[[2]]) && length(argv[[2]]) == 1 && is.numeric(argv[[3]]) && length(argv[[3]]) == 1 && is.numeric(argv[[4]]) && length(argv[[4]]) == 1) {
      f <- condassign__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_adubref') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1 && extends(argtypes[3], '_p_badouble') && length(argv[[3]]) == 1 && extends(argtypes[4], '_p_badouble') && length(argv[[4]]) == 1) {
      f <- condassign__SWIG_4; 
    }
    else if (extends(argtypes[1], '_p_adouble') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1 && extends(argtypes[3], '_p_badouble') && length(argv[[3]]) == 1 && extends(argtypes[4], '_p_badouble') && length(argv[[4]]) == 1) {
      f <- condassign__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for condassign with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of condeqassign

`condeqassign__SWIG_4` = function(s_arg1, s_arg2, s_arg3, s_arg4)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  if (inherits(s_arg3, "ExternalReference")) s_arg3 = slot(s_arg3,"ref") 
  if (inherits(s_arg4, "ExternalReference")) s_arg4 = slot(s_arg4,"ref") 
  ;.Call('R_swig_condeqassign__SWIG_4', s_arg1, s_arg2, s_arg3, s_arg4, PACKAGE='autodiffadolc');
  
}

attr(`condeqassign__SWIG_4`, 'returnType') = 'void'
attr(`condeqassign__SWIG_4`, "inputTypes") = c('_p_adubref', '_p_badouble', '_p_badouble', '_p_badouble')
class(`condeqassign__SWIG_4`) = c("SWIGFunction", class('condeqassign__SWIG_4'))

# Start of condeqassign

`condeqassign__SWIG_5` = function(s_arg1, s_arg2, s_arg3)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  if (inherits(s_arg3, "ExternalReference")) s_arg3 = slot(s_arg3,"ref") 
  ;.Call('R_swig_condeqassign__SWIG_5', s_arg1, s_arg2, s_arg3, PACKAGE='autodiffadolc');
  
}

attr(`condeqassign__SWIG_5`, 'returnType') = 'void'
attr(`condeqassign__SWIG_5`, "inputTypes") = c('_p_adubref', '_p_badouble', '_p_badouble')
class(`condeqassign__SWIG_5`) = c("SWIGFunction", class('condeqassign__SWIG_5'))

`condeqassign` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 6
  if (argc == 3) {
    if (is.numeric(argv[[1]]) && length(argv[[1]]) == 1 && is.numeric(argv[[2]]) && length(argv[[2]]) == 1 && is.numeric(argv[[3]]) && length(argv[[3]]) == 1) {
      f <- condeqassign__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_adouble') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1 && extends(argtypes[3], '_p_badouble') && length(argv[[3]]) == 1) {
      f <- condeqassign__SWIG_3; 
    }
    else if (extends(argtypes[1], '_p_adubref') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1 && extends(argtypes[3], '_p_badouble') && length(argv[[3]]) == 1) {
      f <- condeqassign__SWIG_5; 
    }
  } else if (argc == 4) {
    if (is.numeric(argv[[1]]) && length(argv[[1]]) == 1 && is.numeric(argv[[2]]) && length(argv[[2]]) == 1 && is.numeric(argv[[3]]) && length(argv[[3]]) == 1 && is.numeric(argv[[4]]) && length(argv[[4]]) == 1) {
      f <- condeqassign__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_adubref') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1 && extends(argtypes[3], '_p_badouble') && length(argv[[3]]) == 1 && extends(argtypes[4], '_p_badouble') && length(argv[[4]]) == 1) {
      f <- condeqassign__SWIG_4; 
    }
    else if (extends(argtypes[1], '_p_adouble') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1 && extends(argtypes[3], '_p_badouble') && length(argv[[3]]) == 1 && extends(argtypes[4], '_p_badouble') && length(argv[[4]]) == 1) {
      f <- condeqassign__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for condeqassign with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_adubref

`delete_adubref` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_adubref', self, PACKAGE='autodiffadolc');
  
}

attr(`delete_adubref`, 'returnType') = 'void'
attr(`delete_adubref`, "inputTypes") = c('_p_adubref')
class(`delete_adubref`) = c("SWIGFunction", class('delete_adubref'))

# Start of accessor method for adubref
setMethod('$', '_p_adubref', function(x, name)

{
  accessorFuns = list('__plusplus__' = adubref___plusplus__, '__minusminus__' = adubref___minusminus__, '__seteq__' = adubref___seteq__, 'PlusEqual' = adubref_PlusEqual, 'MinusEqual' = adubref_MinusEqual, 'MultiplyEqual' = adubref_MultiplyEqual, 'DivideEqual' = adubref_DivideEqual, 'declareIndependent' = adubref_declareIndependent, 'declareDependent' = adubref_declareDependent);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for adubref
setMethod('delete', '_p_adubref', function(obj) {delete_adubref(obj)})
# Start of adolc_vec_copy

`adolc_vec_copy` = function(s_arg1, s_arg2, s_arg3)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  if (inherits(s_arg3, "ExternalReference")) s_arg3 = slot(s_arg3,"ref") 
  ;.Call('R_swig_adolc_vec_copy', s_arg1, s_arg2, s_arg3, PACKAGE='autodiffadolc');
  
}

attr(`adolc_vec_copy`, 'returnType') = 'void'
attr(`adolc_vec_copy`, "inputTypes") = c('_p_adouble', '_p_adouble', '_p_uint32_t')
class(`adolc_vec_copy`) = c("SWIGFunction", class('adolc_vec_copy'))

# Start of adolc_vec_axpy

`adolc_vec_axpy` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  if (inherits(s_arg3, "ExternalReference")) s_arg3 = slot(s_arg3,"ref") 
  if (inherits(s_arg4, "ExternalReference")) s_arg4 = slot(s_arg4,"ref") 
  if (inherits(s_arg5, "ExternalReference")) s_arg5 = slot(s_arg5,"ref") 
  ;.Call('R_swig_adolc_vec_axpy', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, PACKAGE='autodiffadolc');
  
}

attr(`adolc_vec_axpy`, 'returnType') = 'void'
attr(`adolc_vec_axpy`, "inputTypes") = c('_p_adouble', '_p_badouble', '_p_adouble', '_p_adouble', '_p_uint32_t')
class(`adolc_vec_axpy`) = c("SWIGFunction", class('adolc_vec_axpy'))

# Start of new_advector

`advector__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_advector__SWIG_0', PACKAGE='autodiffadolc');
  ans <- new("_p_advector", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_advector)
  ans
  
}

attr(`advector__SWIG_0`, 'returnType') = '_p_advector'
class(`advector__SWIG_0`) = c("SWIGFunction", class('advector__SWIG_0'))

# Start of new_advector

`advector__SWIG_1` = function(n)
{
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;ans = .Call('R_swig_new_advector__SWIG_1', n, PACKAGE='autodiffadolc');
  ans <- new("_p_advector", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_advector)
  ans
  
}

attr(`advector__SWIG_1`, 'returnType') = '_p_advector'
attr(`advector__SWIG_1`, "inputTypes") = c('integer')
class(`advector__SWIG_1`) = c("SWIGFunction", class('advector__SWIG_1'))

# Start of delete_advector

`delete_advector` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_advector', self, PACKAGE='autodiffadolc');
  
}

attr(`delete_advector`, 'returnType') = 'void'
attr(`delete_advector`, "inputTypes") = c('_p_advector')
class(`delete_advector`) = c("SWIGFunction", class('delete_advector'))

# Start of new_advector

`advector__SWIG_2` = function(x)
{
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;ans = .Call('R_swig_new_advector__SWIG_2', x, PACKAGE='autodiffadolc');
  ans <- new("_p_advector", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_advector)
  ans
  
}

attr(`advector__SWIG_2`, 'returnType') = '_p_advector'
attr(`advector__SWIG_2`, "inputTypes") = c('_p_advector')
class(`advector__SWIG_2`) = c("SWIGFunction", class('advector__SWIG_2'))

# Start of new_advector

`advector__SWIG_3` = function(v)
{
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;ans = .Call('R_swig_new_advector__SWIG_3', v, PACKAGE='autodiffadolc');
  ans <- new("_p_advector", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_advector)
  ans
  
}

attr(`advector__SWIG_3`, 'returnType') = '_p_advector'
attr(`advector__SWIG_3`, "inputTypes") = c('_p_std__vectorT_adouble_t')
class(`advector__SWIG_3`) = c("SWIGFunction", class('advector__SWIG_3'))

`advector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- advector__SWIG_0; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_advector') && length(argv[[1]]) == 1) {
      f <- advector__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_adouble_t') && length(argv[[1]]) == 1) {
      f <- advector__SWIG_3; 
    }
    else if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- advector__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for advector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of advector_size

`advector_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_advector_size', self, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`advector_size`, 'returnType') = 'integer'
attr(`advector_size`, "inputTypes") = c('_p_advector')
class(`advector_size`) = c("SWIGFunction", class('advector_size'))

# Start of advector___index__

`advector___index____SWIG_0` = function(self, index)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(index, "ExternalReference")) index = slot(index,"ref") 
  ;ans = .Call('R_swig_advector___index____SWIG_0', self, index, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`advector___index____SWIG_0`, 'returnType') = '_p_adub'
attr(`advector___index____SWIG_0`, "inputTypes") = c('_p_advector', '_p_badouble')
class(`advector___index____SWIG_0`) = c("SWIGFunction", class('advector___index____SWIG_0'))

# Start of advector___index__

`advector___index____SWIG_1` = function(self, index)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(index, "ExternalReference")) index = slot(index,"ref") 
  ;ans = .Call('R_swig_advector___index____SWIG_1', self, index, PACKAGE='autodiffadolc');
  ans <- new("_p_adubref", ref=ans) ;
  
  ans
  
}

attr(`advector___index____SWIG_1`, 'returnType') = '_p_adubref'
attr(`advector___index____SWIG_1`, "inputTypes") = c('_p_advector', '_p_badouble')
class(`advector___index____SWIG_1`) = c("SWIGFunction", class('advector___index____SWIG_1'))

# Start of advector___index__

`advector___index____SWIG_2` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_advector___index____SWIG_2', self, i, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adouble", ref=ans) ;
  
  ans
  
}

attr(`advector___index____SWIG_2`, 'returnType') = '_p_adouble'
attr(`advector___index____SWIG_2`, "inputTypes") = c('_p_advector', 'integer')
class(`advector___index____SWIG_2`) = c("SWIGFunction", class('advector___index____SWIG_2'))

# Start of advector___index__

`advector___index____SWIG_3` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_advector___index____SWIG_3', self, i, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adouble", ref=ans) ;
  
  ans
  
}

attr(`advector___index____SWIG_3`, 'returnType') = '_p_adouble'
attr(`advector___index____SWIG_3`, "inputTypes") = c('_p_advector', 'integer')
class(`advector___index____SWIG_3`) = c("SWIGFunction", class('advector___index____SWIG_3'))

`advector___index__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 2) {
    if (extends(argtypes[1], '_p_advector') && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- advector___index____SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_advector') && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- advector___index____SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_advector') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- advector___index____SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_advector') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- advector___index____SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for advector___index__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of advector_lookupindex

`advector_lookupindex` = function(self, x, y, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  if (inherits(y, "ExternalReference")) y = slot(y,"ref") 
  ;ans = .Call('R_swig_advector_lookupindex', self, x, y, as.logical(.copy), PACKAGE='autodiffadolc');
  ans <- new("_p_adouble", ref=ans);
  
  ans
  
}

attr(`advector_lookupindex`, 'returnType') = '_p_adouble'
attr(`advector_lookupindex`, "inputTypes") = c('_p_advector', '_p_badouble', '_p_badouble')
class(`advector_lookupindex`) = c("SWIGFunction", class('advector_lookupindex'))

# Start of accessor method for advector
setMethod('$', '_p_advector', function(x, name)

{
  accessorFuns = list('size' = advector_size, '__index__' = advector___index__, 'lookupindex' = advector_lookupindex);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for advector
setMethod('delete', '_p_advector', function(obj) {delete_advector(obj)})
# Start of reg_ext_fct

`reg_ext_fct__SWIG_0` = function(ext_fct)
{
  if (inherits(ext_fct, "ExternalReference")) ext_fct = slot(ext_fct,"ref") 
  ;ans = .Call('R_swig_reg_ext_fct__SWIG_0', ext_fct, PACKAGE='autodiffadolc');
  ans <- new("_p_ext_diff_fct", ref=ans) ;
  
  ans
  
}

attr(`reg_ext_fct__SWIG_0`, 'returnType') = '_p_ext_diff_fct'
attr(`reg_ext_fct__SWIG_0`, "inputTypes") = c('_p_f_int_p_double_int_p_double__int')
class(`reg_ext_fct__SWIG_0`) = c("SWIGFunction", class('reg_ext_fct__SWIG_0'))

# Start of reg_ext_fct

`reg_ext_fct__SWIG_1` = function(ext_fct)
{
  if (inherits(ext_fct, "ExternalReference")) ext_fct = slot(ext_fct,"ref") 
  ;ans = .Call('R_swig_reg_ext_fct__SWIG_1', ext_fct, PACKAGE='autodiffadolc');
  ans <- new("_p_ext_diff_fct", ref=ans) ;
  
  ans
  
}

attr(`reg_ext_fct__SWIG_1`, 'returnType') = '_p_ext_diff_fct'
attr(`reg_ext_fct__SWIG_1`, "inputTypes") = c('_p_f_int_p_int_int_p_double_int_p_double__int')
class(`reg_ext_fct__SWIG_1`) = c("SWIGFunction", class('reg_ext_fct__SWIG_1'))

# Start of call_ext_fct

`call_ext_fct__SWIG_0` = function(edfct, n, xa, m, ya, .copy = FALSE)
{
  if (inherits(edfct, "ExternalReference")) edfct = slot(edfct,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  if (inherits(xa, "ExternalReference")) xa = slot(xa,"ref") 
  m = as.integer(m);
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  if (inherits(ya, "ExternalReference")) ya = slot(ya,"ref") 
  ;.Call('R_swig_call_ext_fct__SWIG_0', edfct, n, xa, m, ya, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`call_ext_fct__SWIG_0`, 'returnType') = 'integer'
attr(`call_ext_fct__SWIG_0`, "inputTypes") = c('_p_ext_diff_fct', 'integer', '_p_adouble', 'integer', '_p_adouble')
class(`call_ext_fct__SWIG_0`) = c("SWIGFunction", class('call_ext_fct__SWIG_0'))

# Start of call_ext_fct

`call_ext_fct__SWIG_1` = function(edfct, iArrLength, iArr, n, xa, m, ya, .copy = FALSE)
{
  if (inherits(edfct, "ExternalReference")) edfct = slot(edfct,"ref") 
  iArrLength = as.integer(iArrLength);
  
  if(length(iArrLength) > 1) {
    warning("using only the first element of iArrLength");
  };
  
  iArr = as.integer(iArr);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  if (inherits(xa, "ExternalReference")) xa = slot(xa,"ref") 
  m = as.integer(m);
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  if (inherits(ya, "ExternalReference")) ya = slot(ya,"ref") 
  ;.Call('R_swig_call_ext_fct__SWIG_1', edfct, iArrLength, iArr, n, xa, m, ya, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`call_ext_fct__SWIG_1`, 'returnType') = 'integer'
attr(`call_ext_fct__SWIG_1`, "inputTypes") = c('_p_ext_diff_fct', 'integer', 'integer', 'integer', '_p_adouble', 'integer', '_p_adouble')
class(`call_ext_fct__SWIG_1`) = c("SWIGFunction", class('call_ext_fct__SWIG_1'))

# Start of edf_zero

`edf_zero__SWIG_0` = function(edfct)
{
  if (inherits(edfct, "ExternalReference")) edfct = slot(edfct,"ref") 
  ;.Call('R_swig_edf_zero__SWIG_0', edfct, PACKAGE='autodiffadolc');
  
}

attr(`edf_zero__SWIG_0`, 'returnType') = 'void'
attr(`edf_zero__SWIG_0`, "inputTypes") = c('_p_ext_diff_fct')
class(`edf_zero__SWIG_0`) = c("SWIGFunction", class('edf_zero__SWIG_0'))

# Start of reg_ext_fct

`reg_ext_fct__SWIG_2` = function(ext_fct)
{
  if (inherits(ext_fct, "ExternalReference")) ext_fct = slot(ext_fct,"ref") 
  ;ans = .Call('R_swig_reg_ext_fct__SWIG_2', ext_fct, PACKAGE='autodiffadolc');
  ans <- new("_p_ext_diff_fct_v2", ref=ans) ;
  
  ans
  
}

attr(`reg_ext_fct__SWIG_2`, 'returnType') = '_p_ext_diff_fct_v2'
attr(`reg_ext_fct__SWIG_2`, "inputTypes") = c('_p_f_int_p_int_int_int_p_int_p_p_double_p_int_p_p_double_p_void__int')
class(`reg_ext_fct__SWIG_2`) = c("SWIGFunction", class('reg_ext_fct__SWIG_2'))

`reg_ext_fct` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 1) {
    if (extends(argtypes[1], '_p_f_int_p_double_int_p_double__int')) {
      f <- reg_ext_fct__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_f_int_p_int_int_p_double_int_p_double__int')) {
      f <- reg_ext_fct__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_f_int_p_int_int_int_p_int_p_p_double_p_int_p_p_double_p_void__int')) {
      f <- reg_ext_fct__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for reg_ext_fct with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of call_ext_fct

`call_ext_fct__SWIG_2` = function(edfct, iArrLen, iArr, nin, nout, insz, x, outsz, y, .copy = FALSE)
{
  if (inherits(edfct, "ExternalReference")) edfct = slot(edfct,"ref") 
  iArrLen = as.integer(iArrLen);
  
  if(length(iArrLen) > 1) {
    warning("using only the first element of iArrLen");
  };
  
  iArr = as.integer(iArr);
  nin = as.integer(nin);
  
  if(length(nin) > 1) {
    warning("using only the first element of nin");
  };
  
  nout = as.integer(nout);
  
  if(length(nout) > 1) {
    warning("using only the first element of nout");
  };
  
  insz = as.integer(insz);
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  outsz = as.integer(outsz);
  if (inherits(y, "ExternalReference")) y = slot(y,"ref") 
  ;.Call('R_swig_call_ext_fct__SWIG_2', edfct, iArrLen, iArr, nin, nout, insz, x, outsz, y, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`call_ext_fct__SWIG_2`, 'returnType') = 'integer'
attr(`call_ext_fct__SWIG_2`, "inputTypes") = c('_p_ext_diff_fct_v2', 'integer', 'integer', 'integer', 'integer', 'integer', '_p_p_adouble', 'integer', '_p_p_adouble')
class(`call_ext_fct__SWIG_2`) = c("SWIGFunction", class('call_ext_fct__SWIG_2'))

`call_ext_fct` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 5) {
    if (extends(argtypes[1], '_p_ext_diff_fct') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && extends(argtypes[3], '_p_adouble') && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && extends(argtypes[5], '_p_adouble')) {
      f <- call_ext_fct__SWIG_0; 
    }
  } else if (argc == 7) {
    if (extends(argtypes[1], '_p_ext_diff_fct') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.integer(argv[[3]]) || is.numeric(argv[[3]]) ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && extends(argtypes[5], '_p_adouble') && ( (is.integer(argv[[6]]) || is.numeric(argv[[6]])) && length(argv[[6]]) == 1 ) && extends(argtypes[7], '_p_adouble')) {
      f <- call_ext_fct__SWIG_1; 
    }
  } else if (argc == 9) {
    if (extends(argtypes[1], '_p_ext_diff_fct_v2') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.integer(argv[[3]]) || is.numeric(argv[[3]]) ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 ) && ( is.integer(argv[[6]]) || is.numeric(argv[[6]]) ) && extends(argtypes[7], '_p_p_adouble') && ( is.integer(argv[[8]]) || is.numeric(argv[[8]]) ) && extends(argtypes[9], '_p_p_adouble')) {
      f <- call_ext_fct__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for call_ext_fct with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of edf_zero

`edf_zero__SWIG_1` = function(edfct)
{
  if (inherits(edfct, "ExternalReference")) edfct = slot(edfct,"ref") 
  ;.Call('R_swig_edf_zero__SWIG_1', edfct, PACKAGE='autodiffadolc');
  
}

attr(`edf_zero__SWIG_1`, 'returnType') = 'void'
attr(`edf_zero__SWIG_1`, "inputTypes") = c('_p_ext_diff_fct_v2')
class(`edf_zero__SWIG_1`) = c("SWIGFunction", class('edf_zero__SWIG_1'))

`edf_zero` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_ext_diff_fct')) {
      f <- edf_zero__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_ext_diff_fct_v2')) {
      f <- edf_zero__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for edf_zero with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of edf_set_opaque_context

`edf_set_opaque_context` = function(edfct, ctx)
{
  if (inherits(edfct, "ExternalReference")) edfct = slot(edfct,"ref") 
  if (inherits(ctx, "ExternalReference")) ctx = slot(ctx,"ref") 
  ;.Call('R_swig_edf_set_opaque_context', edfct, ctx, PACKAGE='autodiffadolc');
  
}

attr(`edf_set_opaque_context`, 'returnType') = 'void'
attr(`edf_set_opaque_context`, "inputTypes") = c('_p_ext_diff_fct_v2', '_p_void')
class(`edf_set_opaque_context`) = c("SWIGFunction", class('edf_set_opaque_context'))

# Start of reg_timestep_fct

`reg_timestep_fct` = function(timeStepFunction)
{
  if (inherits(timeStepFunction, "ExternalReference")) timeStepFunction = slot(timeStepFunction,"ref") 
  ;ans = .Call('R_swig_reg_timestep_fct', timeStepFunction, PACKAGE='autodiffadolc');
  ans <- new("_p_CpInfos", ref=ans) ;
  
  ans
  
}

attr(`reg_timestep_fct`, 'returnType') = '_p_CpInfos'
attr(`reg_timestep_fct`, "inputTypes") = c('_p_f_int_p_adouble__int')
class(`reg_timestep_fct`) = c("SWIGFunction", class('reg_timestep_fct'))

# Start of checkpointing

`checkpointing` = function(cpInfos, .copy = FALSE)
{
  if (inherits(cpInfos, "ExternalReference")) cpInfos = slot(cpInfos,"ref") 
  ;.Call('R_swig_checkpointing', cpInfos, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`checkpointing`, 'returnType') = 'integer'
attr(`checkpointing`, "inputTypes") = c('_p_CpInfos')
class(`checkpointing`) = c("SWIGFunction", class('checkpointing'))

# Start of reinit_checkpointing

`reinit_checkpointing` = function()
{
  ;.Call('R_swig_reinit_checkpointing', PACKAGE='autodiffadolc');
  
}

attr(`reinit_checkpointing`, 'returnType') = 'void'
class(`reinit_checkpointing`) = c("SWIGFunction", class('reinit_checkpointing'))

# Start of new_CP_Context

`CP_Context` = function(tsf)
{
  if (inherits(tsf, "ExternalReference")) tsf = slot(tsf,"ref") 
  ;ans = .Call('R_swig_new_CP_Context', tsf, PACKAGE='autodiffadolc');
  ans <- new("_p_CP_Context", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_CP_Context)
  ans
  
}

attr(`CP_Context`, 'returnType') = '_p_CP_Context'
attr(`CP_Context`, "inputTypes") = c('_p_f_int_p_adouble__int')
class(`CP_Context`) = c("SWIGFunction", class('CP_Context'))

# Start of delete_CP_Context

`delete_CP_Context` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_CP_Context', self, PACKAGE='autodiffadolc');
  
}

attr(`delete_CP_Context`, 'returnType') = 'void'
attr(`delete_CP_Context`, "inputTypes") = c('_p_CP_Context')
class(`delete_CP_Context`) = c("SWIGFunction", class('delete_CP_Context'))

# Start of CP_Context_setDoubleFct

`CP_Context_setDoubleFct` = function(self, tsf)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(tsf, "ExternalReference")) tsf = slot(tsf,"ref") 
  ;.Call('R_swig_CP_Context_setDoubleFct', self, tsf, PACKAGE='autodiffadolc');
  
}

attr(`CP_Context_setDoubleFct`, 'returnType') = 'void'
attr(`CP_Context_setDoubleFct`, "inputTypes") = c('_p_CP_Context', '_p_f_int_p_double__int')
class(`CP_Context_setDoubleFct`) = c("SWIGFunction", class('CP_Context_setDoubleFct'))

# Start of CP_Context_setSaveFct

`CP_Context_setSaveFct` = function(self, sf)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(sf, "ExternalReference")) sf = slot(sf,"ref") 
  ;.Call('R_swig_CP_Context_setSaveFct', self, sf, PACKAGE='autodiffadolc');
  
}

attr(`CP_Context_setSaveFct`, 'returnType') = 'void'
attr(`CP_Context_setSaveFct`, "inputTypes") = c('_p_CP_Context', '_p_f___p_void')
class(`CP_Context_setSaveFct`) = c("SWIGFunction", class('CP_Context_setSaveFct'))

# Start of CP_Context_setRestoreFct

`CP_Context_setRestoreFct` = function(self, rf)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(rf, "ExternalReference")) rf = slot(rf,"ref") 
  ;.Call('R_swig_CP_Context_setRestoreFct', self, rf, PACKAGE='autodiffadolc');
  
}

attr(`CP_Context_setRestoreFct`, 'returnType') = 'void'
attr(`CP_Context_setRestoreFct`, "inputTypes") = c('_p_CP_Context', '_p_f_p_void__void')
class(`CP_Context_setRestoreFct`) = c("SWIGFunction", class('CP_Context_setRestoreFct'))

# Start of CP_Context_setNumberOfSteps

`CP_Context_setNumberOfSteps` = function(self, number)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  number = as.integer(number);
  
  if(length(number) > 1) {
    warning("using only the first element of number");
  };
  
  ;.Call('R_swig_CP_Context_setNumberOfSteps', self, number, PACKAGE='autodiffadolc');
  
}

attr(`CP_Context_setNumberOfSteps`, 'returnType') = 'void'
attr(`CP_Context_setNumberOfSteps`, "inputTypes") = c('_p_CP_Context', 'integer')
class(`CP_Context_setNumberOfSteps`) = c("SWIGFunction", class('CP_Context_setNumberOfSteps'))

# Start of CP_Context_setNumberOfCheckpoints

`CP_Context_setNumberOfCheckpoints` = function(self, number)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  number = as.integer(number);
  
  if(length(number) > 1) {
    warning("using only the first element of number");
  };
  
  ;.Call('R_swig_CP_Context_setNumberOfCheckpoints', self, number, PACKAGE='autodiffadolc');
  
}

attr(`CP_Context_setNumberOfCheckpoints`, 'returnType') = 'void'
attr(`CP_Context_setNumberOfCheckpoints`, "inputTypes") = c('_p_CP_Context', 'integer')
class(`CP_Context_setNumberOfCheckpoints`) = c("SWIGFunction", class('CP_Context_setNumberOfCheckpoints'))

# Start of CP_Context_setTapeNumber

`CP_Context_setTapeNumber` = function(self, tapeNumber)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  tapeNumber = as.integer(tapeNumber);
  
  if(length(tapeNumber) > 1) {
    warning("using only the first element of tapeNumber");
  };
  
  ;.Call('R_swig_CP_Context_setTapeNumber', self, tapeNumber, PACKAGE='autodiffadolc');
  
}

attr(`CP_Context_setTapeNumber`, 'returnType') = 'void'
attr(`CP_Context_setTapeNumber`, "inputTypes") = c('_p_CP_Context', 'integer')
class(`CP_Context_setTapeNumber`) = c("SWIGFunction", class('CP_Context_setTapeNumber'))

# Start of CP_Context_setDimensionXY

`CP_Context_setDimensionXY` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_CP_Context_setDimensionXY', self, n, PACKAGE='autodiffadolc');
  
}

attr(`CP_Context_setDimensionXY`, 'returnType') = 'void'
attr(`CP_Context_setDimensionXY`, "inputTypes") = c('_p_CP_Context', 'integer')
class(`CP_Context_setDimensionXY`) = c("SWIGFunction", class('CP_Context_setDimensionXY'))

# Start of CP_Context_setInput

`CP_Context_setInput` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_CP_Context_setInput', self, x, PACKAGE='autodiffadolc');
  
}

attr(`CP_Context_setInput`, 'returnType') = 'void'
attr(`CP_Context_setInput`, "inputTypes") = c('_p_CP_Context', '_p_adouble')
class(`CP_Context_setInput`) = c("SWIGFunction", class('CP_Context_setInput'))

# Start of CP_Context_setOutput

`CP_Context_setOutput` = function(self, y)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(y, "ExternalReference")) y = slot(y,"ref") 
  ;.Call('R_swig_CP_Context_setOutput', self, y, PACKAGE='autodiffadolc');
  
}

attr(`CP_Context_setOutput`, 'returnType') = 'void'
attr(`CP_Context_setOutput`, "inputTypes") = c('_p_CP_Context', '_p_adouble')
class(`CP_Context_setOutput`) = c("SWIGFunction", class('CP_Context_setOutput'))

# Start of CP_Context_setAlwaysRetaping

`CP_Context_setAlwaysRetaping` = function(self, state)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  state = as.logical(state);
  ;.Call('R_swig_CP_Context_setAlwaysRetaping', self, state, PACKAGE='autodiffadolc');
  
}

attr(`CP_Context_setAlwaysRetaping`, 'returnType') = 'void'
attr(`CP_Context_setAlwaysRetaping`, "inputTypes") = c('_p_CP_Context', 'logical')
class(`CP_Context_setAlwaysRetaping`) = c("SWIGFunction", class('CP_Context_setAlwaysRetaping'))

# Start of CP_Context_checkpointing

`CP_Context_checkpointing` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_CP_Context_checkpointing', self, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`CP_Context_checkpointing`, 'returnType') = 'integer'
attr(`CP_Context_checkpointing`, "inputTypes") = c('_p_CP_Context')
class(`CP_Context_checkpointing`) = c("SWIGFunction", class('CP_Context_checkpointing'))

# Start of accessor method for CP_Context
setMethod('$', '_p_CP_Context', function(x, name)

{
  accessorFuns = list('setDoubleFct' = CP_Context_setDoubleFct, 'setSaveFct' = CP_Context_setSaveFct, 'setRestoreFct' = CP_Context_setRestoreFct, 'setNumberOfSteps' = CP_Context_setNumberOfSteps, 'setNumberOfCheckpoints' = CP_Context_setNumberOfCheckpoints, 'setTapeNumber' = CP_Context_setTapeNumber, 'setDimensionXY' = CP_Context_setDimensionXY, 'setInput' = CP_Context_setInput, 'setOutput' = CP_Context_setOutput, 'setAlwaysRetaping' = CP_Context_setAlwaysRetaping, 'checkpointing' = CP_Context_checkpointing);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for CP_Context
setMethod('delete', '_p_CP_Context', function(obj) {delete_CP_Context(obj)})
# Start of fp_iteration

`fp_iteration` = function(sub_tape_num, double_F, adouble_F, norm, norm_deriv, epsilon, epsilon_deriv, N_max, N_max_deriv, x_0, u, x_fix, dim_x, dim_u, .copy = FALSE)
{
  sub_tape_num = as.integer(sub_tape_num);
  
  if(length(sub_tape_num) > 1) {
    warning("using only the first element of sub_tape_num");
  };
  
  if(is.function(double_F)) {
    assert('...' %in% names(formals(double_F)) || length(formals(double_F)) >= 5);
  } else {
    if(is.character(double_F)) {
      double_F = getNativeSymbolInfo(double_F);
    };
    if(is(double_F, "NativeSymbolInfo")) {
      double_F = double_F$address;
    }
    if(is(double_F, "ExternalReference")) {
      double_F = double_F@ref;
    }
  }; 
  if(is.function(adouble_F)) {
    assert('...' %in% names(formals(adouble_F)) || length(formals(adouble_F)) >= 5);
  } else {
    if(is.character(adouble_F)) {
      adouble_F = getNativeSymbolInfo(adouble_F);
    };
    if(is(adouble_F, "NativeSymbolInfo")) {
      adouble_F = adouble_F$address;
    }
    if(is(adouble_F, "ExternalReference")) {
      adouble_F = adouble_F@ref;
    }
  }; 
  if(is.function(norm)) {
    assert('...' %in% names(formals(norm)) || length(formals(norm)) >= 2);
  } else {
    if(is.character(norm)) {
      norm = getNativeSymbolInfo(norm);
    };
    if(is(norm, "NativeSymbolInfo")) {
      norm = norm$address;
    }
    if(is(norm, "ExternalReference")) {
      norm = norm@ref;
    }
  }; 
  if(is.function(norm_deriv)) {
    assert('...' %in% names(formals(norm_deriv)) || length(formals(norm_deriv)) >= 0);
  } else {
    if(is.character(norm_deriv)) {
      norm_deriv = getNativeSymbolInfo(norm_deriv);
    };
    if(is(norm_deriv, "NativeSymbolInfo")) {
      norm_deriv = norm_deriv$address;
    }
    if(is(norm_deriv, "ExternalReference")) {
      norm_deriv = norm_deriv@ref;
    }
  }; 
  
  
  N_max = as.integer(N_max);
  
  if(length(N_max) > 1) {
    warning("using only the first element of N_max");
  };
  
  N_max_deriv = as.integer(N_max_deriv);
  
  if(length(N_max_deriv) > 1) {
    warning("using only the first element of N_max_deriv");
  };
  
  if (inherits(x_0, "ExternalReference")) x_0 = slot(x_0,"ref") 
  if (inherits(u, "ExternalReference")) u = slot(u,"ref") 
  if (inherits(x_fix, "ExternalReference")) x_fix = slot(x_fix,"ref") 
  dim_x = as.integer(dim_x);
  
  if(length(dim_x) > 1) {
    warning("using only the first element of dim_x");
  };
  
  dim_u = as.integer(dim_u);
  
  if(length(dim_u) > 1) {
    warning("using only the first element of dim_u");
  };
  
  ;.Call('R_swig_fp_iteration', sub_tape_num, double_F, adouble_F, norm, norm_deriv, epsilon, epsilon_deriv, N_max, N_max_deriv, x_0, u, x_fix, dim_x, dim_u, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`fp_iteration`, 'returnType') = 'integer'
attr(`fp_iteration`, "inputTypes") = c('integer', '_p_f_p_double_p_double_p_double_int_int__int', '_p_f_p_adouble_p_adouble_p_adouble_int_int__int', '_p_f_p_double_int__double', '_p_f_p_double_int__double', 'numeric', 'numeric', 'integer', 'integer', '_p_adouble', '_p_adouble', '_p_adouble', 'integer', 'integer')
class(`fp_iteration`) = c("SWIGFunction", class('fp_iteration'))

# Start of forward

`forward__SWIG_0` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  s_arg5 = as.integer(s_arg5);
  
  if(length(s_arg5) > 1) {
    warning("using only the first element of s_arg5");
  };
  
  
  
  ;.Call('R_swig_forward__SWIG_0', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`forward__SWIG_0`, 'returnType') = 'integer'
attr(`forward__SWIG_0`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'integer', 'numeric', 'numeric')
class(`forward__SWIG_0`) = c("SWIGFunction", class('forward__SWIG_0'))

# Start of forward

`forward__SWIG_1` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  s_arg5 = as.integer(s_arg5);
  
  if(length(s_arg5) > 1) {
    warning("using only the first element of s_arg5");
  };
  
  
  
  ;.Call('R_swig_forward__SWIG_1', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`forward__SWIG_1`, 'returnType') = 'integer'
attr(`forward__SWIG_1`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'integer', 'numeric', 'numeric')
class(`forward__SWIG_1`) = c("SWIGFunction", class('forward__SWIG_1'))

# Start of forward

`forward__SWIG_2` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  s_arg5 = as.integer(s_arg5);
  
  if(length(s_arg5) > 1) {
    warning("using only the first element of s_arg5");
  };
  
  
  
  ;.Call('R_swig_forward__SWIG_2', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`forward__SWIG_2`, 'returnType') = 'integer'
attr(`forward__SWIG_2`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'integer', 'numeric', 'numeric')
class(`forward__SWIG_2`) = c("SWIGFunction", class('forward__SWIG_2'))

# Start of forward

`forward__SWIG_3` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  
  
  ;.Call('R_swig_forward__SWIG_3', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`forward__SWIG_3`, 'returnType') = 'integer'
attr(`forward__SWIG_3`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'numeric', 'numeric')
class(`forward__SWIG_3`) = c("SWIGFunction", class('forward__SWIG_3'))

# Start of forward

`forward__SWIG_4` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, s_arg9, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  s_arg5 = as.integer(s_arg5);
  
  if(length(s_arg5) > 1) {
    warning("using only the first element of s_arg5");
  };
  
  
  if (inherits(s_arg7, "ExternalReference")) s_arg7 = slot(s_arg7,"ref") 
  
  if (inherits(s_arg9, "ExternalReference")) s_arg9 = slot(s_arg9,"ref") 
  ;.Call('R_swig_forward__SWIG_4', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, s_arg9, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`forward__SWIG_4`, 'returnType') = 'integer'
attr(`forward__SWIG_4`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'integer', 'numeric', '_p_p_p_double', 'numeric', '_p_p_p_double')
class(`forward__SWIG_4`) = c("SWIGFunction", class('forward__SWIG_4'))

# Start of forward

`forward__SWIG_5` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  
  
  
  
  ;.Call('R_swig_forward__SWIG_5', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`forward__SWIG_5`, 'returnType') = 'integer'
attr(`forward__SWIG_5`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'numeric', 'numeric', 'numeric', 'numeric')
class(`forward__SWIG_5`) = c("SWIGFunction", class('forward__SWIG_5'))

`forward` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 6
  if (argc == 6) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( is.numeric(argv[[5]]) ) && ( is.numeric(argv[[6]]) )) {
      f <- forward__SWIG_3; 
    }
  } else if (argc == 7) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 ) && ( is.numeric(argv[[6]]) ) && ( is.numeric(argv[[7]]) )) {
      f <- forward__SWIG_1; 
    }
    else if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 ) && ( is.numeric(argv[[6]]) ) && ( is.numeric(argv[[7]]) )) {
      f <- forward__SWIG_2; 
    }
    else if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 ) && ( is.numeric(argv[[6]]) ) && ( is.numeric(argv[[7]]) )) {
      f <- forward__SWIG_0; 
    }
  } else if (argc == 8) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( is.numeric(argv[[5]]) ) && ( is.numeric(argv[[6]]) ) && ( is.numeric(argv[[7]]) ) && ( is.numeric(argv[[8]]) )) {
      f <- forward__SWIG_5; 
    }
  } else if (argc == 9) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 ) && ( is.numeric(argv[[6]]) ) && extends(argtypes[7], '_p_p_p_double') && ( is.numeric(argv[[8]]) ) && extends(argtypes[9], '_p_p_p_double')) {
      f <- forward__SWIG_4; 
    }
  } else {
    stop("cannot find overloaded function for forward with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of reverse

`reverse__SWIG_0` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  
  
  ;.Call('R_swig_reverse__SWIG_0', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`reverse__SWIG_0`, 'returnType') = 'integer'
attr(`reverse__SWIG_0`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'numeric', 'numeric')
class(`reverse__SWIG_0`) = c("SWIGFunction", class('reverse__SWIG_0'))

# Start of reverse

`reverse__SWIG_1` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  
  
  ;.Call('R_swig_reverse__SWIG_1', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`reverse__SWIG_1`, 'returnType') = 'integer'
attr(`reverse__SWIG_1`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'numeric', 'numeric')
class(`reverse__SWIG_1`) = c("SWIGFunction", class('reverse__SWIG_1'))

# Start of reverse

`reverse__SWIG_2` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  
  
  ;.Call('R_swig_reverse__SWIG_2', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`reverse__SWIG_2`, 'returnType') = 'integer'
attr(`reverse__SWIG_2`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'numeric', 'numeric')
class(`reverse__SWIG_2`) = c("SWIGFunction", class('reverse__SWIG_2'))

# Start of reverse

`reverse__SWIG_3` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  
  
  ;.Call('R_swig_reverse__SWIG_3', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`reverse__SWIG_3`, 'returnType') = 'integer'
attr(`reverse__SWIG_3`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'numeric', 'numeric')
class(`reverse__SWIG_3`) = c("SWIGFunction", class('reverse__SWIG_3'))

# Start of reverse

`reverse__SWIG_4` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  s_arg5 = as.integer(s_arg5);
  
  if(length(s_arg5) > 1) {
    warning("using only the first element of s_arg5");
  };
  
  
  if (inherits(s_arg7, "ExternalReference")) s_arg7 = slot(s_arg7,"ref") 
  if (inherits(s_arg8, "ExternalReference")) s_arg8 = slot(s_arg8,"ref") 
  ;.Call('R_swig_reverse__SWIG_4', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`reverse__SWIG_4`, 'returnType') = 'integer'
attr(`reverse__SWIG_4`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'integer', 'numeric', '_p_p_p_double', '_p_p_short')
class(`reverse__SWIG_4`) = c("SWIGFunction", class('reverse__SWIG_4'))

# Start of reverse

`reverse__SWIG_5` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  s_arg5 = as.integer(s_arg5);
  
  if(length(s_arg5) > 1) {
    warning("using only the first element of s_arg5");
  };
  
  
  if (inherits(s_arg7, "ExternalReference")) s_arg7 = slot(s_arg7,"ref") 
  ;.Call('R_swig_reverse__SWIG_5', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`reverse__SWIG_5`, 'returnType') = 'integer'
attr(`reverse__SWIG_5`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'integer', 'numeric', '_p_p_p_double')
class(`reverse__SWIG_5`) = c("SWIGFunction", class('reverse__SWIG_5'))

# Start of reverse

`reverse__SWIG_6` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  s_arg5 = as.integer(s_arg5);
  
  if(length(s_arg5) > 1) {
    warning("using only the first element of s_arg5");
  };
  
  
  if (inherits(s_arg7, "ExternalReference")) s_arg7 = slot(s_arg7,"ref") 
  if (inherits(s_arg8, "ExternalReference")) s_arg8 = slot(s_arg8,"ref") 
  ;.Call('R_swig_reverse__SWIG_6', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`reverse__SWIG_6`, 'returnType') = 'integer'
attr(`reverse__SWIG_6`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'integer', 'numeric', '_p_p_p_double', '_p_p_short')
class(`reverse__SWIG_6`) = c("SWIGFunction", class('reverse__SWIG_6'))

# Start of reverse

`reverse__SWIG_7` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  s_arg5 = as.integer(s_arg5);
  
  if(length(s_arg5) > 1) {
    warning("using only the first element of s_arg5");
  };
  
  
  if (inherits(s_arg7, "ExternalReference")) s_arg7 = slot(s_arg7,"ref") 
  ;.Call('R_swig_reverse__SWIG_7', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`reverse__SWIG_7`, 'returnType') = 'integer'
attr(`reverse__SWIG_7`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'integer', 'numeric', '_p_p_p_double')
class(`reverse__SWIG_7`) = c("SWIGFunction", class('reverse__SWIG_7'))

# Start of reverse

`reverse__SWIG_8` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  s_arg5 = as.integer(s_arg5);
  
  if(length(s_arg5) > 1) {
    warning("using only the first element of s_arg5");
  };
  
  
  
  ;.Call('R_swig_reverse__SWIG_8', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`reverse__SWIG_8`, 'returnType') = 'integer'
attr(`reverse__SWIG_8`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'integer', 'numeric', 'numeric')
class(`reverse__SWIG_8`) = c("SWIGFunction", class('reverse__SWIG_8'))

# Start of reverse

`reverse__SWIG_9` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  
  
  ;.Call('R_swig_reverse__SWIG_9', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`reverse__SWIG_9`, 'returnType') = 'integer'
attr(`reverse__SWIG_9`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'numeric', 'numeric')
class(`reverse__SWIG_9`) = c("SWIGFunction", class('reverse__SWIG_9'))

# Start of reverse

`reverse__SWIG_10` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  s_arg5 = as.integer(s_arg5);
  
  if(length(s_arg5) > 1) {
    warning("using only the first element of s_arg5");
  };
  
  
  
  ;.Call('R_swig_reverse__SWIG_10', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`reverse__SWIG_10`, 'returnType') = 'integer'
attr(`reverse__SWIG_10`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'integer', 'numeric', 'numeric')
class(`reverse__SWIG_10`) = c("SWIGFunction", class('reverse__SWIG_10'))

# Start of reverse

`reverse__SWIG_11` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  if (inherits(s_arg5, "ExternalReference")) s_arg5 = slot(s_arg5,"ref") 
  if (inherits(s_arg6, "ExternalReference")) s_arg6 = slot(s_arg6,"ref") 
  ;.Call('R_swig_reverse__SWIG_11', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`reverse__SWIG_11`, 'returnType') = 'integer'
attr(`reverse__SWIG_11`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', '_p_p_p_double', '_p_p_short')
class(`reverse__SWIG_11`) = c("SWIGFunction", class('reverse__SWIG_11'))

# Start of reverse

`reverse__SWIG_12` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  if (inherits(s_arg5, "ExternalReference")) s_arg5 = slot(s_arg5,"ref") 
  ;.Call('R_swig_reverse__SWIG_12', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`reverse__SWIG_12`, 'returnType') = 'integer'
attr(`reverse__SWIG_12`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', '_p_p_p_double')
class(`reverse__SWIG_12`) = c("SWIGFunction", class('reverse__SWIG_12'))

`reverse` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 13
  if (argc == 5) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && extends(argtypes[5], '_p_p_p_double')) {
      f <- reverse__SWIG_12; 
    }
  } else if (argc == 6) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && extends(argtypes[5], '_p_p_p_double') && extends(argtypes[6], '_p_p_short')) {
      f <- reverse__SWIG_11; 
    }
    else if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( is.numeric(argv[[5]]) && length(argv[[5]]) == 1 ) && ( is.numeric(argv[[6]]) )) {
      f <- reverse__SWIG_3; 
    }
    else if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( is.numeric(argv[[5]]) && length(argv[[5]]) == 1 ) && ( is.numeric(argv[[6]]) )) {
      f <- reverse__SWIG_1; 
    }
    else if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( is.numeric(argv[[5]]) ) && ( is.numeric(argv[[6]]) )) {
      f <- reverse__SWIG_9; 
    }
    else if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( is.numeric(argv[[5]]) ) && ( is.numeric(argv[[6]]) )) {
      f <- reverse__SWIG_2; 
    }
    else if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( is.numeric(argv[[5]]) ) && ( is.numeric(argv[[6]]) )) {
      f <- reverse__SWIG_0; 
    }
  } else if (argc == 7) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 ) && ( is.numeric(argv[[6]]) ) && extends(argtypes[7], '_p_p_p_double')) {
      f <- reverse__SWIG_5; 
    }
    else if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 ) && ( is.numeric(argv[[6]]) ) && extends(argtypes[7], '_p_p_p_double')) {
      f <- reverse__SWIG_7; 
    }
    else if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 ) && ( is.numeric(argv[[6]]) ) && ( is.numeric(argv[[7]]) )) {
      f <- reverse__SWIG_10; 
    }
    else if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 ) && ( is.numeric(argv[[6]]) ) && ( is.numeric(argv[[7]]) )) {
      f <- reverse__SWIG_8; 
    }
  } else if (argc == 8) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 ) && ( is.numeric(argv[[6]]) ) && extends(argtypes[7], '_p_p_p_double') && extends(argtypes[8], '_p_p_short')) {
      f <- reverse__SWIG_4; 
    }
    else if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 ) && ( is.numeric(argv[[6]]) ) && extends(argtypes[7], '_p_p_p_double') && extends(argtypes[8], '_p_p_short')) {
      f <- reverse__SWIG_6; 
    }
  } else {
    stop("cannot find overloaded function for reverse with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of zos_forward

`zos_forward` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  
  
  ;.Call('R_swig_zos_forward', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`zos_forward`, 'returnType') = 'integer'
attr(`zos_forward`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'numeric', 'numeric')
class(`zos_forward`) = c("SWIGFunction", class('zos_forward'))

# Start of zos_forward_partx

`zos_forward_partx` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  
  ;.Call('R_swig_zos_forward_partx', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`zos_forward_partx`, 'returnType') = 'integer'
attr(`zos_forward_partx`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'numeric', 'numeric')
class(`zos_forward_partx`) = c("SWIGFunction", class('zos_forward_partx'))

# Start of fos_forward

`fos_forward` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  
  
  
  
  ;.Call('R_swig_fos_forward', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`fos_forward`, 'returnType') = 'integer'
attr(`fos_forward`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'numeric', 'numeric', 'numeric', 'numeric')
class(`fos_forward`) = c("SWIGFunction", class('fos_forward'))

# Start of fos_forward_partx

`fos_forward_partx` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  if (inherits(s_arg5, "ExternalReference")) s_arg5 = slot(s_arg5,"ref") 
  
  ;.Call('R_swig_fos_forward_partx', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`fos_forward_partx`, 'returnType') = 'integer'
attr(`fos_forward_partx`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', '_p_p_p_double', 'numeric')
class(`fos_forward_partx`) = c("SWIGFunction", class('fos_forward_partx'))

# Start of hos_forward

`hos_forward` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, s_arg9, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  s_arg5 = as.integer(s_arg5);
  
  if(length(s_arg5) > 1) {
    warning("using only the first element of s_arg5");
  };
  
  
  
  
  
  ;.Call('R_swig_hos_forward', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, s_arg9, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`hos_forward`, 'returnType') = 'integer'
attr(`hos_forward`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'integer', 'numeric', 'numeric', 'numeric', 'numeric')
class(`hos_forward`) = c("SWIGFunction", class('hos_forward'))

# Start of hos_forward_partx

`hos_forward_partx` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  s_arg5 = as.integer(s_arg5);
  
  if(length(s_arg5) > 1) {
    warning("using only the first element of s_arg5");
  };
  
  if (inherits(s_arg6, "ExternalReference")) s_arg6 = slot(s_arg6,"ref") 
  
  ;.Call('R_swig_hos_forward_partx', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`hos_forward_partx`, 'returnType') = 'integer'
attr(`hos_forward_partx`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'integer', '_p_p_p_double', 'numeric')
class(`hos_forward_partx`) = c("SWIGFunction", class('hos_forward_partx'))

# Start of fov_forward

`fov_forward` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  
  
  
  
  ;.Call('R_swig_fov_forward', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`fov_forward`, 'returnType') = 'integer'
attr(`fov_forward`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'numeric', 'numeric', 'numeric', 'numeric')
class(`fov_forward`) = c("SWIGFunction", class('fov_forward'))

# Start of fov_offset_forward

`fov_offset_forward` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, s_arg9, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  s_arg5 = as.integer(s_arg5);
  
  if(length(s_arg5) > 1) {
    warning("using only the first element of s_arg5");
  };
  
  
  
  
  
  ;.Call('R_swig_fov_offset_forward', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, s_arg9, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`fov_offset_forward`, 'returnType') = 'integer'
attr(`fov_offset_forward`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'integer', 'numeric', 'numeric', 'numeric', 'numeric')
class(`fov_offset_forward`) = c("SWIGFunction", class('fov_offset_forward'))

# Start of fov_forward_partx

`fov_forward_partx` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, s_arg9, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  s_arg5 = as.integer(s_arg5);
  
  if(length(s_arg5) > 1) {
    warning("using only the first element of s_arg5");
  };
  
  
  if (inherits(s_arg7, "ExternalReference")) s_arg7 = slot(s_arg7,"ref") 
  
  
  ;.Call('R_swig_fov_forward_partx', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, s_arg9, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`fov_forward_partx`, 'returnType') = 'integer'
attr(`fov_forward_partx`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'integer', 'numeric', '_p_p_p_double', 'numeric', 'numeric')
class(`fov_forward_partx`) = c("SWIGFunction", class('fov_forward_partx'))

# Start of hov_forward

`hov_forward` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, s_arg9, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  s_arg5 = as.integer(s_arg5);
  
  if(length(s_arg5) > 1) {
    warning("using only the first element of s_arg5");
  };
  
  
  if (inherits(s_arg7, "ExternalReference")) s_arg7 = slot(s_arg7,"ref") 
  
  if (inherits(s_arg9, "ExternalReference")) s_arg9 = slot(s_arg9,"ref") 
  ;.Call('R_swig_hov_forward', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, s_arg9, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`hov_forward`, 'returnType') = 'integer'
attr(`hov_forward`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'integer', 'numeric', '_p_p_p_double', 'numeric', '_p_p_p_double')
class(`hov_forward`) = c("SWIGFunction", class('hov_forward'))

# Start of hov_forward_partx

`hov_forward_partx` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, s_arg9, s_arg10, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  s_arg5 = as.integer(s_arg5);
  
  if(length(s_arg5) > 1) {
    warning("using only the first element of s_arg5");
  };
  
  s_arg6 = as.integer(s_arg6);
  
  if(length(s_arg6) > 1) {
    warning("using only the first element of s_arg6");
  };
  
  
  if (inherits(s_arg8, "ExternalReference")) s_arg8 = slot(s_arg8,"ref") 
  
  if (inherits(s_arg10, "ExternalReference")) s_arg10 = slot(s_arg10,"ref") 
  ;.Call('R_swig_hov_forward_partx', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, s_arg9, s_arg10, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`hov_forward_partx`, 'returnType') = 'integer'
attr(`hov_forward_partx`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'integer', 'integer', 'numeric', '_p_p_p_p_double', 'numeric', '_p_p_p_double')
class(`hov_forward_partx`) = c("SWIGFunction", class('hov_forward_partx'))

# Start of hov_wk_forward

`hov_wk_forward` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, s_arg9, s_arg10, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  s_arg5 = as.integer(s_arg5);
  
  if(length(s_arg5) > 1) {
    warning("using only the first element of s_arg5");
  };
  
  s_arg6 = as.integer(s_arg6);
  
  if(length(s_arg6) > 1) {
    warning("using only the first element of s_arg6");
  };
  
  
  if (inherits(s_arg8, "ExternalReference")) s_arg8 = slot(s_arg8,"ref") 
  
  if (inherits(s_arg10, "ExternalReference")) s_arg10 = slot(s_arg10,"ref") 
  ;.Call('R_swig_hov_wk_forward', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, s_arg9, s_arg10, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`hov_wk_forward`, 'returnType') = 'integer'
attr(`hov_wk_forward`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'integer', 'integer', 'numeric', '_p_p_p_double', 'numeric', '_p_p_p_double')
class(`hov_wk_forward`) = c("SWIGFunction", class('hov_wk_forward'))

# Start of int_forward_safe

`int_forward_safe` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  if (inherits(s_arg5, "ExternalReference")) s_arg5 = slot(s_arg5,"ref") 
  if (inherits(s_arg6, "ExternalReference")) s_arg6 = slot(s_arg6,"ref") 
  ;.Call('R_swig_int_forward_safe', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`int_forward_safe`, 'returnType') = 'integer'
attr(`int_forward_safe`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', '_p_p_unsigned_long', '_p_p_unsigned_long')
class(`int_forward_safe`) = c("SWIGFunction", class('int_forward_safe'))

# Start of int_forward_tight

`int_forward_tight` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  
  if (inherits(s_arg6, "ExternalReference")) s_arg6 = slot(s_arg6,"ref") 
  
  if (inherits(s_arg8, "ExternalReference")) s_arg8 = slot(s_arg8,"ref") 
  ;.Call('R_swig_int_forward_tight', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`int_forward_tight`, 'returnType') = 'integer'
attr(`int_forward_tight`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'numeric', '_p_p_unsigned_long', 'numeric', '_p_p_unsigned_long')
class(`int_forward_tight`) = c("SWIGFunction", class('int_forward_tight'))

# Start of indopro_forward_safe

`indopro_forward_safe` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  
  if (inherits(s_arg5, "ExternalReference")) s_arg5 = slot(s_arg5,"ref") 
  ;.Call('R_swig_indopro_forward_safe', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`indopro_forward_safe`, 'returnType') = 'integer'
attr(`indopro_forward_safe`, "inputTypes") = c('integer', 'integer', 'integer', 'numeric', '_p_p_unsigned_int')
class(`indopro_forward_safe`) = c("SWIGFunction", class('indopro_forward_safe'))

# Start of indopro_forward_tight

`indopro_forward_tight` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  
  if (inherits(s_arg5, "ExternalReference")) s_arg5 = slot(s_arg5,"ref") 
  ;.Call('R_swig_indopro_forward_tight', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`indopro_forward_tight`, 'returnType') = 'integer'
attr(`indopro_forward_tight`, "inputTypes") = c('integer', 'integer', 'integer', 'numeric', '_p_p_unsigned_int')
class(`indopro_forward_tight`) = c("SWIGFunction", class('indopro_forward_tight'))

# Start of nonl_ind_forward_safe

`nonl_ind_forward_safe` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  
  if (inherits(s_arg5, "ExternalReference")) s_arg5 = slot(s_arg5,"ref") 
  ;.Call('R_swig_nonl_ind_forward_safe', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`nonl_ind_forward_safe`, 'returnType') = 'integer'
attr(`nonl_ind_forward_safe`, "inputTypes") = c('integer', 'integer', 'integer', 'numeric', '_p_p_unsigned_int')
class(`nonl_ind_forward_safe`) = c("SWIGFunction", class('nonl_ind_forward_safe'))

# Start of nonl_ind_forward_tight

`nonl_ind_forward_tight` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  
  if (inherits(s_arg5, "ExternalReference")) s_arg5 = slot(s_arg5,"ref") 
  ;.Call('R_swig_nonl_ind_forward_tight', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`nonl_ind_forward_tight`, 'returnType') = 'integer'
attr(`nonl_ind_forward_tight`, "inputTypes") = c('integer', 'integer', 'integer', 'numeric', '_p_p_unsigned_int')
class(`nonl_ind_forward_tight`) = c("SWIGFunction", class('nonl_ind_forward_tight'))

# Start of nonl_ind_old_forward_safe

`nonl_ind_old_forward_safe` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  
  if (inherits(s_arg5, "ExternalReference")) s_arg5 = slot(s_arg5,"ref") 
  ;.Call('R_swig_nonl_ind_old_forward_safe', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`nonl_ind_old_forward_safe`, 'returnType') = 'integer'
attr(`nonl_ind_old_forward_safe`, "inputTypes") = c('integer', 'integer', 'integer', 'numeric', '_p_p_unsigned_int')
class(`nonl_ind_old_forward_safe`) = c("SWIGFunction", class('nonl_ind_old_forward_safe'))

# Start of nonl_ind_old_forward_tight

`nonl_ind_old_forward_tight` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  
  if (inherits(s_arg5, "ExternalReference")) s_arg5 = slot(s_arg5,"ref") 
  ;.Call('R_swig_nonl_ind_old_forward_tight', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`nonl_ind_old_forward_tight`, 'returnType') = 'integer'
attr(`nonl_ind_old_forward_tight`, "inputTypes") = c('integer', 'integer', 'integer', 'numeric', '_p_p_unsigned_int')
class(`nonl_ind_old_forward_tight`) = c("SWIGFunction", class('nonl_ind_old_forward_tight'))

# Start of fos_reverse

`fos_reverse` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  
  
  ;.Call('R_swig_fos_reverse', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`fos_reverse`, 'returnType') = 'integer'
attr(`fos_reverse`, "inputTypes") = c('integer', 'integer', 'integer', 'numeric', 'numeric')
class(`fos_reverse`) = c("SWIGFunction", class('fos_reverse'))

# Start of hos_reverse

`hos_reverse` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  
  
  ;.Call('R_swig_hos_reverse', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`hos_reverse`, 'returnType') = 'integer'
attr(`hos_reverse`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'numeric', 'numeric')
class(`hos_reverse`) = c("SWIGFunction", class('hos_reverse'))

# Start of hos_ti_reverse

`hos_ti_reverse` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  
  
  ;.Call('R_swig_hos_ti_reverse', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`hos_ti_reverse`, 'returnType') = 'integer'
attr(`hos_ti_reverse`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'numeric', 'numeric')
class(`hos_ti_reverse`) = c("SWIGFunction", class('hos_ti_reverse'))

# Start of hos_ov_reverse

`hos_ov_reverse` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  s_arg5 = as.integer(s_arg5);
  
  if(length(s_arg5) > 1) {
    warning("using only the first element of s_arg5");
  };
  
  
  if (inherits(s_arg7, "ExternalReference")) s_arg7 = slot(s_arg7,"ref") 
  ;.Call('R_swig_hos_ov_reverse', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`hos_ov_reverse`, 'returnType') = 'integer'
attr(`hos_ov_reverse`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'integer', 'numeric', '_p_p_p_double')
class(`hos_ov_reverse`) = c("SWIGFunction", class('hos_ov_reverse'))

# Start of fov_reverse

`fov_reverse` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  
  
  ;.Call('R_swig_fov_reverse', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`fov_reverse`, 'returnType') = 'integer'
attr(`fov_reverse`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'numeric', 'numeric')
class(`fov_reverse`) = c("SWIGFunction", class('fov_reverse'))

# Start of hov_reverse

`hov_reverse` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  s_arg5 = as.integer(s_arg5);
  
  if(length(s_arg5) > 1) {
    warning("using only the first element of s_arg5");
  };
  
  
  if (inherits(s_arg7, "ExternalReference")) s_arg7 = slot(s_arg7,"ref") 
  if (inherits(s_arg8, "ExternalReference")) s_arg8 = slot(s_arg8,"ref") 
  ;.Call('R_swig_hov_reverse', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`hov_reverse`, 'returnType') = 'integer'
attr(`hov_reverse`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'integer', 'numeric', '_p_p_p_double', '_p_p_short')
class(`hov_reverse`) = c("SWIGFunction", class('hov_reverse'))

# Start of hov_ti_reverse

`hov_ti_reverse` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  s_arg5 = as.integer(s_arg5);
  
  if(length(s_arg5) > 1) {
    warning("using only the first element of s_arg5");
  };
  
  if (inherits(s_arg6, "ExternalReference")) s_arg6 = slot(s_arg6,"ref") 
  if (inherits(s_arg7, "ExternalReference")) s_arg7 = slot(s_arg7,"ref") 
  if (inherits(s_arg8, "ExternalReference")) s_arg8 = slot(s_arg8,"ref") 
  ;.Call('R_swig_hov_ti_reverse', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`hov_ti_reverse`, 'returnType') = 'integer'
attr(`hov_ti_reverse`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'integer', '_p_p_p_double', '_p_p_p_double', '_p_p_short')
class(`hov_ti_reverse`) = c("SWIGFunction", class('hov_ti_reverse'))

# Start of int_reverse_tight

`int_reverse_tight` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  if (inherits(s_arg5, "ExternalReference")) s_arg5 = slot(s_arg5,"ref") 
  if (inherits(s_arg6, "ExternalReference")) s_arg6 = slot(s_arg6,"ref") 
  ;.Call('R_swig_int_reverse_tight', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`int_reverse_tight`, 'returnType') = 'integer'
attr(`int_reverse_tight`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', '_p_p_unsigned_long', '_p_p_unsigned_long')
class(`int_reverse_tight`) = c("SWIGFunction", class('int_reverse_tight'))

# Start of int_reverse_safe

`int_reverse_safe` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  if (inherits(s_arg5, "ExternalReference")) s_arg5 = slot(s_arg5,"ref") 
  if (inherits(s_arg6, "ExternalReference")) s_arg6 = slot(s_arg6,"ref") 
  ;.Call('R_swig_int_reverse_safe', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`int_reverse_safe`, 'returnType') = 'integer'
attr(`int_reverse_safe`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', '_p_p_unsigned_long', '_p_p_unsigned_long')
class(`int_reverse_safe`) = c("SWIGFunction", class('int_reverse_safe'))

# Start of get_num_switches

`get_num_switches` = function(s_arg1, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  ;.Call('R_swig_get_num_switches', s_arg1, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`get_num_switches`, 'returnType') = 'integer'
attr(`get_num_switches`, "inputTypes") = c('integer')
class(`get_num_switches`) = c("SWIGFunction", class('get_num_switches'))

# Start of zos_pl_forward

`zos_pl_forward` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  
  
  
  ;.Call('R_swig_zos_pl_forward', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`zos_pl_forward`, 'returnType') = 'integer'
attr(`zos_pl_forward`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'numeric', 'numeric', 'numeric')
class(`zos_pl_forward`) = c("SWIGFunction", class('zos_pl_forward'))

# Start of firstsign

`firstsign` = function(s_arg1, s_arg2, s_arg3, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  
  
  ;.Call('R_swig_firstsign', s_arg1, s_arg2, s_arg3, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`firstsign`, 'returnType') = 'integer'
attr(`firstsign`, "inputTypes") = c('integer', 'numeric', 'numeric')
class(`firstsign`) = c("SWIGFunction", class('firstsign'))

# Start of ext_firstsign

`ext_firstsign` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, .copy = FALSE)
{
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  
  
  ;.Call('R_swig_ext_firstsign', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`ext_firstsign`, 'returnType') = 'integer'
attr(`ext_firstsign`, "inputTypes") = c('numeric', 'numeric', 'integer', 'numeric', 'numeric')
class(`ext_firstsign`) = c("SWIGFunction", class('ext_firstsign'))

# Start of ext_firstsign2

`ext_firstsign2` = function(s_arg1, s_arg2, s_arg3, s_arg4, .copy = FALSE)
{
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  
  
  ;.Call('R_swig_ext_firstsign2', s_arg1, s_arg2, s_arg3, s_arg4, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`ext_firstsign2`, 'returnType') = 'integer'
attr(`ext_firstsign2`, "inputTypes") = c('numeric', 'integer', 'numeric', 'numeric')
class(`ext_firstsign2`) = c("SWIGFunction", class('ext_firstsign2'))

# Start of fos_pl_forward

`fos_pl_forward` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, s_arg9, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  
  
  
  
  
  
  ;.Call('R_swig_fos_pl_forward', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, s_arg9, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`fos_pl_forward`, 'returnType') = 'integer'
attr(`fos_pl_forward`, "inputTypes") = c('integer', 'integer', 'integer', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric')
class(`fos_pl_forward`) = c("SWIGFunction", class('fos_pl_forward'))

# Start of fov_pl_forward

`fov_pl_forward` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, s_arg9, s_arg10, s_arg11, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  
  
  
  
  
  
  s_arg11 = as.integer(s_arg11);
  ;.Call('R_swig_fov_pl_forward', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, s_arg9, s_arg10, s_arg11, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`fov_pl_forward`, 'returnType') = 'integer'
attr(`fov_pl_forward`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'integer')
class(`fov_pl_forward`) = c("SWIGFunction", class('fov_pl_forward'))

# Start of fos_pl_sig_forward

`fos_pl_sig_forward` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, s_arg9, s_arg10, s_arg11, s_arg12, s_arg13, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  
  
  s_arg6 = as.integer(s_arg6);
  
  if(length(s_arg6) > 1) {
    warning("using only the first element of s_arg6");
  };
  
  s_arg7 = as.integer(s_arg7);
  s_arg8 = as.integer(s_arg8);
  
  
  
  
  s_arg13 = as.integer(s_arg13);
  ;.Call('R_swig_fos_pl_sig_forward', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, s_arg9, s_arg10, s_arg11, s_arg12, s_arg13, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`fos_pl_sig_forward`, 'returnType') = 'integer'
attr(`fos_pl_sig_forward`, "inputTypes") = c('integer', 'integer', 'integer', 'numeric', 'numeric', 'integer', 'integer', 'integer', 'numeric', 'numeric', 'numeric', 'numeric', 'integer')
class(`fos_pl_sig_forward`) = c("SWIGFunction", class('fos_pl_sig_forward'))

# Start of fov_pl_sig_forward

`fov_pl_sig_forward` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, s_arg9, s_arg10, s_arg11, s_arg12, s_arg13, s_arg14, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  
  
  s_arg7 = as.integer(s_arg7);
  
  if(length(s_arg7) > 1) {
    warning("using only the first element of s_arg7");
  };
  
  s_arg8 = as.integer(s_arg8);
  s_arg9 = as.integer(s_arg9);
  
  
  
  
  s_arg14 = as.integer(s_arg14);
  ;.Call('R_swig_fov_pl_sig_forward', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, s_arg9, s_arg10, s_arg11, s_arg12, s_arg13, s_arg14, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`fov_pl_sig_forward`, 'returnType') = 'integer'
attr(`fov_pl_sig_forward`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'numeric', 'numeric', 'integer', 'integer', 'integer', 'numeric', 'numeric', 'numeric', 'numeric', 'integer')
class(`fov_pl_sig_forward`) = c("SWIGFunction", class('fov_pl_sig_forward'))

# Start of indopro_forward_absnormal

`indopro_forward_absnormal` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  
  if (inherits(s_arg6, "ExternalReference")) s_arg6 = slot(s_arg6,"ref") 
  ;.Call('R_swig_indopro_forward_absnormal', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`indopro_forward_absnormal`, 'returnType') = 'integer'
attr(`indopro_forward_absnormal`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'numeric', '_p_p_unsigned_int')
class(`indopro_forward_absnormal`) = c("SWIGFunction", class('indopro_forward_absnormal'))

# Start of fos_pl_reverse

`fos_pl_reverse` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  s_arg5 = as.integer(s_arg5);
  
  if(length(s_arg5) > 1) {
    warning("using only the first element of s_arg5");
  };
  
  
  ;.Call('R_swig_fos_pl_reverse', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`fos_pl_reverse`, 'returnType') = 'integer'
attr(`fos_pl_reverse`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'integer', 'numeric')
class(`fos_pl_reverse`) = c("SWIGFunction", class('fos_pl_reverse'))

# Start of fos_pl_sig_reverse

`fos_pl_sig_reverse` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  s_arg5 = as.integer(s_arg5);
  
  
  ;.Call('R_swig_fos_pl_sig_reverse', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`fos_pl_sig_reverse`, 'returnType') = 'integer'
attr(`fos_pl_sig_reverse`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'integer', 'numeric', 'numeric')
class(`fos_pl_sig_reverse`) = c("SWIGFunction", class('fos_pl_sig_reverse'))

# Start of eval_func

`eval_func` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  
  
  ;.Call('R_swig_eval_func', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`eval_func`, 'returnType') = 'integer'
attr(`eval_func`, "inputTypes") = c('integer', 'integer', 'integer', 'numeric', 'numeric')
class(`eval_func`) = c("SWIGFunction", class('eval_func'))

# Start of gradient

#' Compute the gradient of the dependent with respect to the independent variable(s)
#' 
#'
#' \code{gradient} computes the derivaties for dependent varible with respect to
#' n independents for the computation that has been traced.
#'
#' @param tag integer for tape identification (used in trace_on())
#' @param n  integer number of independents n and m = 1
#' @param x  independent vector of length n
#' @param  g  resulting gradient (\gradF(x)) of length n 
#' 
#' @return None. the output is the the parameter g
#'
#' @examples
#' x=c(1,2)
#' g <- c(0.0,0.0)
#' gradient(1,2,x,g)
#'
#'@seealso{\code{\link{trace_on}}, \code{\link{trace_off}}, 
#'         \code{\link{badouble_declareIndependent}},
#'         \code{\link{badouble_declareDependent}}}
#'         
#'@keywords{autodiffadolc}
#'
#' @export

`gradient` = function(s_arg1, s_arg2, s_arg3, s_arg4, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  
  
  ;.Call('R_swig_gradient', s_arg1, s_arg2, s_arg3, s_arg4, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`gradient`, 'returnType') = 'integer'
attr(`gradient`, "inputTypes") = c('integer', 'integer', 'numeric', 'numeric')
class(`gradient`) = c("SWIGFunction", class('gradient'))

# Start of jacobian

#' Compute the derivatives of the dependent variables with respect to the independent variables
#' 
#'
#' \code{jacobian} computes the Jacobian matrix values for m dependents with respect to
#' n independents for the computation that has been traced. If m>n then the forward mode of automatic differentiation is used. 
#' Otherwise, the reverse emode of automatic differentiation is used. 
#'
#' @param tag integer for tape identification (used in \link{trace_on})
#' @param m  integer, number of dependent variables
#' @param n  integer number of independents
#' @param x  independent vector of length n
#' @param J[m][n] resulting Jacobian (m*n) F(x) 
#
#' 
#' @return None. the output is the the parameter J
#'
#' @examples
#' jacobian(tag,m,n,x,J)
#'
#' @seealso{\code{\link{trace_on}}, \code{\link{trace_off}}, 
#'         \code{\link{badouble_declareIndependent}},
#'         \code{\link{badouble_declareDependent}}}
#'         
#'@keywords{autodiffadolc}
#'
#' @export

`jacobian` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);

  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);

  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  
  
  ;.Call('R_swig_jacobian', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`jacobian`, 'returnType') = 'integer'
attr(`jacobian`, "inputTypes") = c('integer', 'integer', 'integer', 'numeric', 'numeric')
class(`jacobian`) = c("SWIGFunction", class('jacobian'))

# Start of large_jacobian

`large_jacobian` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  
  
  
  ;.Call('R_swig_large_jacobian', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`large_jacobian`, 'returnType') = 'integer'
attr(`large_jacobian`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'numeric', 'numeric', 'numeric')
class(`large_jacobian`) = c("SWIGFunction", class('large_jacobian'))

# Start of vec_jac

`vec_jac` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  
  
  
  ;.Call('R_swig_vec_jac', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`vec_jac`, 'returnType') = 'integer'
attr(`vec_jac`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'numeric', 'numeric', 'numeric')
class(`vec_jac`) = c("SWIGFunction", class('vec_jac'))

# Start of jac_vec

`jac_vec` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  
  
  
  ;.Call('R_swig_jac_vec', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`jac_vec`, 'returnType') = 'integer'
attr(`jac_vec`, "inputTypes") = c('integer', 'integer', 'integer', 'numeric', 'numeric', 'numeric')
class(`jac_vec`) = c("SWIGFunction", class('jac_vec'))

# Start of hessian

`hessian` = function(s_arg1, s_arg2, s_arg3, s_arg4, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  
  
  ;.Call('R_swig_hessian', s_arg1, s_arg2, s_arg3, s_arg4, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`hessian`, 'returnType') = 'integer'
attr(`hessian`, "inputTypes") = c('integer', 'integer', 'numeric', 'numeric')
class(`hessian`) = c("SWIGFunction", class('hessian'))

# Start of hessian2

`hessian2` = function(s_arg1, s_arg2, s_arg3, s_arg4, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  
  
  ;.Call('R_swig_hessian2', s_arg1, s_arg2, s_arg3, s_arg4, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`hessian2`, 'returnType') = 'integer'
attr(`hessian2`, "inputTypes") = c('integer', 'integer', 'numeric', 'numeric')
class(`hessian2`) = c("SWIGFunction", class('hessian2'))

# Start of hess_vec

`hess_vec` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  
  
  
  ;.Call('R_swig_hess_vec', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`hess_vec`, 'returnType') = 'integer'
attr(`hess_vec`, "inputTypes") = c('integer', 'integer', 'numeric', 'numeric', 'numeric')
class(`hess_vec`) = c("SWIGFunction", class('hess_vec'))

# Start of hess_mat

`hess_mat` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  
  
  
  ;.Call('R_swig_hess_mat', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`hess_mat`, 'returnType') = 'integer'
attr(`hess_mat`, "inputTypes") = c('integer', 'integer', 'integer', 'numeric', 'numeric', 'numeric')
class(`hess_mat`) = c("SWIGFunction", class('hess_mat'))

# Start of lagra_hess_vec

`lagra_hess_vec` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  
  
  
  
  ;.Call('R_swig_lagra_hess_vec', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`lagra_hess_vec`, 'returnType') = 'integer'
attr(`lagra_hess_vec`, "inputTypes") = c('integer', 'integer', 'integer', 'numeric', 'numeric', 'numeric', 'numeric')
class(`lagra_hess_vec`) = c("SWIGFunction", class('lagra_hess_vec'))

# Start of tensor_eval

`tensor_eval` = function(tag, m, n, d, p, x, tensor, S, .copy = FALSE)
{
  tag = as.integer(tag);
  
  if(length(tag) > 1) {
    warning("using only the first element of tag");
  };
  
  m = as.integer(m);
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  d = as.integer(d);
  
  if(length(d) > 1) {
    warning("using only the first element of d");
  };
  
  p = as.integer(p);
  
  if(length(p) > 1) {
    warning("using only the first element of p");
  };
  
  
  
  
  ;.Call('R_swig_tensor_eval', tag, m, n, d, p, x, tensor, S, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`tensor_eval`, 'returnType') = 'integer'
attr(`tensor_eval`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'integer', 'numeric', 'numeric', 'numeric')
class(`tensor_eval`) = c("SWIGFunction", class('tensor_eval'))

# Start of inverse_tensor_eval

`inverse_tensor_eval` = function(tag, n, d, p, x, tensor, S, .copy = FALSE)
{
  tag = as.integer(tag);
  
  if(length(tag) > 1) {
    warning("using only the first element of tag");
  };
  
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  d = as.integer(d);
  
  if(length(d) > 1) {
    warning("using only the first element of d");
  };
  
  p = as.integer(p);
  
  if(length(p) > 1) {
    warning("using only the first element of p");
  };
  
  
  
  
  ;.Call('R_swig_inverse_tensor_eval', tag, n, d, p, x, tensor, S, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`inverse_tensor_eval`, 'returnType') = 'integer'
attr(`inverse_tensor_eval`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'numeric', 'numeric', 'numeric')
class(`inverse_tensor_eval`) = c("SWIGFunction", class('inverse_tensor_eval'))

# Start of inverse_Taylor_prop

`inverse_Taylor_prop` = function(tag, n, d, Y, X, .copy = FALSE)
{
  tag = as.integer(tag);
  
  if(length(tag) > 1) {
    warning("using only the first element of tag");
  };
  
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  d = as.integer(d);
  
  if(length(d) > 1) {
    warning("using only the first element of d");
  };
  
  
  
  ;.Call('R_swig_inverse_Taylor_prop', tag, n, d, Y, X, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`inverse_Taylor_prop`, 'returnType') = 'integer'
attr(`inverse_Taylor_prop`, "inputTypes") = c('integer', 'integer', 'integer', 'numeric', 'numeric')
class(`inverse_Taylor_prop`) = c("SWIGFunction", class('inverse_Taylor_prop'))

# Start of tensor_value

`tensor_value` = function(d, m, y, tensor, multi)
{
  d = as.integer(d);
  
  if(length(d) > 1) {
    warning("using only the first element of d");
  };
  
  m = as.integer(m);
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  
  
  multi = as.integer(multi);
  ;.Call('R_swig_tensor_value', d, m, y, tensor, multi, PACKAGE='autodiffadolc');
  
}

attr(`tensor_value`, 'returnType') = 'void'
attr(`tensor_value`, "inputTypes") = c('integer', 'integer', 'numeric', 'numeric', 'integer')
class(`tensor_value`) = c("SWIGFunction", class('tensor_value'))

# Start of tensorsetup

`tensorsetup` = function(m, p, d, tensorig)
{
  m = as.integer(m);
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  p = as.integer(p);
  
  if(length(p) > 1) {
    warning("using only the first element of p");
  };
  
  d = as.integer(d);
  
  if(length(d) > 1) {
    warning("using only the first element of d");
  };
  
  
  ;ans = .Call('R_swig_tensorsetup', m, p, d, tensorig, PACKAGE='autodiffadolc');
  ans <- new("_p_p_void", ref=ans) ;
  
  ans
  
}

attr(`tensorsetup`, 'returnType') = '_p_p_void'
attr(`tensorsetup`, "inputTypes") = c('integer', 'integer', 'integer', 'numeric')
class(`tensorsetup`) = c("SWIGFunction", class('tensorsetup'))

# Start of freetensor

`freetensor` = function(m, p, d, tensor)
{
  m = as.integer(m);
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  p = as.integer(p);
  
  if(length(p) > 1) {
    warning("using only the first element of p");
  };
  
  d = as.integer(d);
  
  if(length(d) > 1) {
    warning("using only the first element of d");
  };
  
  
  ;.Call('R_swig_freetensor', m, p, d, tensor, PACKAGE='autodiffadolc');
  
}

attr(`freetensor`, 'returnType') = 'void'
attr(`freetensor`, "inputTypes") = c('integer', 'integer', 'integer', 'numeric')
class(`freetensor`) = c("SWIGFunction", class('freetensor'))

# Start of tensor_address

`tensor_address` = function(d, im, .copy = FALSE)
{
  d = as.integer(d);
  
  if(length(d) > 1) {
    warning("using only the first element of d");
  };
  
  im = as.integer(im);
  ;.Call('R_swig_tensor_address', d, im, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`tensor_address`, 'returnType') = 'integer'
attr(`tensor_address`, "inputTypes") = c('integer', 'integer')
class(`tensor_address`) = c("SWIGFunction", class('tensor_address'))

# Start of binomi

`binomi` = function(a, b, .copy = FALSE)
{
  a = as.integer(a);
  
  if(length(a) > 1) {
    warning("using only the first element of a");
  };
  
  b = as.integer(b);
  
  if(length(b) > 1) {
    warning("using only the first element of b");
  };
  
  ;.Call('R_swig_binomi', a, b, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`binomi`, 'returnType') = 'integer'
attr(`binomi`, "inputTypes") = c('integer', 'integer')
class(`binomi`) = c("SWIGFunction", class('binomi'))

# Start of jac_solv

`jac_solv` = function(tag, n, x, b, mode, .copy = FALSE)
{
  tag = as.integer(tag);
  
  if(length(tag) > 1) {
    warning("using only the first element of tag");
  };
  
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  
  mode = as.integer(mode);
  
  if(length(mode) > 1) {
    warning("using only the first element of mode");
  };
  
  ;.Call('R_swig_jac_solv', tag, n, x, b, mode, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`jac_solv`, 'returnType') = 'integer'
attr(`jac_solv`, "inputTypes") = c('integer', 'integer', 'numeric', 'numeric', 'integer')
class(`jac_solv`) = c("SWIGFunction", class('jac_solv'))

# Start of forodec

`forodec` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  s_arg5 = as.integer(s_arg5);
  
  if(length(s_arg5) > 1) {
    warning("using only the first element of s_arg5");
  };
  
  
  ;.Call('R_swig_forodec', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`forodec`, 'returnType') = 'integer'
attr(`forodec`, "inputTypes") = c('integer', 'integer', 'numeric', 'integer', 'integer', 'numeric')
class(`forodec`) = c("SWIGFunction", class('forodec'))

# Start of accodec

`accodec` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  if (inherits(s_arg4, "ExternalReference")) s_arg4 = slot(s_arg4,"ref") 
  if (inherits(s_arg5, "ExternalReference")) s_arg5 = slot(s_arg5,"ref") 
  if (inherits(s_arg6, "ExternalReference")) s_arg6 = slot(s_arg6,"ref") 
  ;.Call('R_swig_accodec', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, PACKAGE='autodiffadolc');
  
}

attr(`accodec`, 'returnType') = 'void'
attr(`accodec`, "inputTypes") = c('integer', 'numeric', 'integer', '_p_p_p_double', '_p_p_p_double', '_p_p_short')
class(`accodec`) = c("SWIGFunction", class('accodec'))

# Start of forode

`forode__SWIG_0` = function(tag, n, tau, dold, dnew, X, .copy = FALSE)
{
  tag = as.integer(tag);
  
  if(length(tag) > 1) {
    warning("using only the first element of tag");
  };
  
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  dold = as.integer(dold);
  
  if(length(dold) > 1) {
    warning("using only the first element of dold");
  };
  
  dnew = as.integer(dnew);
  
  if(length(dnew) > 1) {
    warning("using only the first element of dnew");
  };
  
  
  ;.Call('R_swig_forode__SWIG_0', tag, n, tau, dold, dnew, X, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`forode__SWIG_0`, 'returnType') = 'integer'
attr(`forode__SWIG_0`, "inputTypes") = c('integer', 'integer', 'numeric', 'integer', 'integer', 'numeric')
class(`forode__SWIG_0`) = c("SWIGFunction", class('forode__SWIG_0'))

# Start of forode

`forode__SWIG_1` = function(tag, n, dold, dnew, X, .copy = FALSE)
{
  tag = as.integer(tag);
  
  if(length(tag) > 1) {
    warning("using only the first element of tag");
  };
  
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  dold = as.integer(dold);
  
  if(length(dold) > 1) {
    warning("using only the first element of dold");
  };
  
  dnew = as.integer(dnew);
  
  if(length(dnew) > 1) {
    warning("using only the first element of dnew");
  };
  
  
  ;.Call('R_swig_forode__SWIG_1', tag, n, dold, dnew, X, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`forode__SWIG_1`, 'returnType') = 'integer'
attr(`forode__SWIG_1`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'numeric')
class(`forode__SWIG_1`) = c("SWIGFunction", class('forode__SWIG_1'))

# Start of forode

`forode__SWIG_2` = function(tag, n, tau, deg, X, .copy = FALSE)
{
  tag = as.integer(tag);
  
  if(length(tag) > 1) {
    warning("using only the first element of tag");
  };
  
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  deg = as.integer(deg);
  
  if(length(deg) > 1) {
    warning("using only the first element of deg");
  };
  
  
  ;.Call('R_swig_forode__SWIG_2', tag, n, tau, deg, X, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`forode__SWIG_2`, 'returnType') = 'integer'
attr(`forode__SWIG_2`, "inputTypes") = c('integer', 'integer', 'numeric', 'integer', 'numeric')
class(`forode__SWIG_2`) = c("SWIGFunction", class('forode__SWIG_2'))

# Start of forode

`forode__SWIG_3` = function(tag, n, deg, X, .copy = FALSE)
{
  tag = as.integer(tag);
  
  if(length(tag) > 1) {
    warning("using only the first element of tag");
  };
  
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  deg = as.integer(deg);
  
  if(length(deg) > 1) {
    warning("using only the first element of deg");
  };
  
  
  ;.Call('R_swig_forode__SWIG_3', tag, n, deg, X, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`forode__SWIG_3`, 'returnType') = 'integer'
attr(`forode__SWIG_3`, "inputTypes") = c('integer', 'integer', 'integer', 'numeric')
class(`forode__SWIG_3`) = c("SWIGFunction", class('forode__SWIG_3'))

`forode` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 4) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( is.numeric(argv[[4]]) )) {
      f <- forode__SWIG_3; 
    }
  } else if (argc == 5) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( is.numeric(argv[[5]]) )) {
      f <- forode__SWIG_1; 
    }
    else if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( is.numeric(argv[[5]]) )) {
      f <- forode__SWIG_2; 
    }
  } else if (argc == 6) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 ) && ( is.numeric(argv[[6]]) )) {
      f <- forode__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for forode with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of accode

`accode__SWIG_0` = function(n, tau, deg, A, B, nonzero)
{
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  deg = as.integer(deg);
  
  if(length(deg) > 1) {
    warning("using only the first element of deg");
  };
  
  if (inherits(A, "ExternalReference")) A = slot(A,"ref") 
  if (inherits(B, "ExternalReference")) B = slot(B,"ref") 
  if (inherits(nonzero, "ExternalReference")) nonzero = slot(nonzero,"ref") 
  ;.Call('R_swig_accode__SWIG_0', n, tau, deg, A, B, nonzero, PACKAGE='autodiffadolc');
  
}

attr(`accode__SWIG_0`, 'returnType') = 'void'
attr(`accode__SWIG_0`, "inputTypes") = c('integer', 'numeric', 'integer', '_p_p_p_double', '_p_p_p_double', '_p_p_short')
class(`accode__SWIG_0`) = c("SWIGFunction", class('accode__SWIG_0'))

# Start of accode

`accode__SWIG_1` = function(n, tau, deg, A, B)
{
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  deg = as.integer(deg);
  
  if(length(deg) > 1) {
    warning("using only the first element of deg");
  };
  
  if (inherits(A, "ExternalReference")) A = slot(A,"ref") 
  if (inherits(B, "ExternalReference")) B = slot(B,"ref") 
  ;.Call('R_swig_accode__SWIG_1', n, tau, deg, A, B, PACKAGE='autodiffadolc');
  
}

attr(`accode__SWIG_1`, 'returnType') = 'void'
attr(`accode__SWIG_1`, "inputTypes") = c('integer', 'numeric', 'integer', '_p_p_p_double', '_p_p_p_double')
class(`accode__SWIG_1`) = c("SWIGFunction", class('accode__SWIG_1'))

# Start of accode

`accode__SWIG_2` = function(n, deg, A, B, nonzero)
{
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  deg = as.integer(deg);
  
  if(length(deg) > 1) {
    warning("using only the first element of deg");
  };
  
  if (inherits(A, "ExternalReference")) A = slot(A,"ref") 
  if (inherits(B, "ExternalReference")) B = slot(B,"ref") 
  if (inherits(nonzero, "ExternalReference")) nonzero = slot(nonzero,"ref") 
  ;.Call('R_swig_accode__SWIG_2', n, deg, A, B, nonzero, PACKAGE='autodiffadolc');
  
}

attr(`accode__SWIG_2`, 'returnType') = 'void'
attr(`accode__SWIG_2`, "inputTypes") = c('integer', 'integer', '_p_p_p_double', '_p_p_p_double', '_p_p_short')
class(`accode__SWIG_2`) = c("SWIGFunction", class('accode__SWIG_2'))

# Start of accode

`accode__SWIG_3` = function(n, deg, A, B)
{
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  deg = as.integer(deg);
  
  if(length(deg) > 1) {
    warning("using only the first element of deg");
  };
  
  if (inherits(A, "ExternalReference")) A = slot(A,"ref") 
  if (inherits(B, "ExternalReference")) B = slot(B,"ref") 
  ;.Call('R_swig_accode__SWIG_3', n, deg, A, B, PACKAGE='autodiffadolc');
  
}

attr(`accode__SWIG_3`, 'returnType') = 'void'
attr(`accode__SWIG_3`, "inputTypes") = c('integer', 'integer', '_p_p_p_double', '_p_p_p_double')
class(`accode__SWIG_3`) = c("SWIGFunction", class('accode__SWIG_3'))

`accode` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 4) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && extends(argtypes[3], '_p_p_p_double') && extends(argtypes[4], '_p_p_p_double')) {
      f <- accode__SWIG_3; 
    }
  } else if (argc == 5) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && extends(argtypes[3], '_p_p_p_double') && extends(argtypes[4], '_p_p_p_double') && extends(argtypes[5], '_p_p_short')) {
      f <- accode__SWIG_2; 
    }
    else if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && extends(argtypes[4], '_p_p_p_double') && extends(argtypes[5], '_p_p_p_double')) {
      f <- accode__SWIG_1; 
    }
  } else if (argc == 6) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && extends(argtypes[4], '_p_p_p_double') && extends(argtypes[5], '_p_p_p_double') && extends(argtypes[6], '_p_p_short')) {
      f <- accode__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for accode with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of directional_active_gradient

`directional_active_gradient` = function(tag, n, x, d, g, sigma_g, .copy = FALSE)
{
  tag = as.integer(tag);
  
  if(length(tag) > 1) {
    warning("using only the first element of tag");
  };
  
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  
  
  sigma_g = as.integer(sigma_g);
  ;.Call('R_swig_directional_active_gradient', tag, n, x, d, g, sigma_g, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`directional_active_gradient`, 'returnType') = 'integer'
attr(`directional_active_gradient`, "inputTypes") = c('integer', 'integer', 'numeric', 'numeric', 'numeric', 'integer')
class(`directional_active_gradient`) = c("SWIGFunction", class('directional_active_gradient'))

# Start of abs_normal

`abs_normal` = function(tag, m, n, swchk, x, sigma, y, z, cz, cy, J, Y, Z, L, .copy = FALSE)
{
  tag = as.integer(tag);
  
  if(length(tag) > 1) {
    warning("using only the first element of tag");
  };
  
  m = as.integer(m);
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  swchk = as.integer(swchk);
  
  if(length(swchk) > 1) {
    warning("using only the first element of swchk");
  };
  
  
  sigma = as.integer(sigma);
  
  
  
  
  
  
  
  
  ;.Call('R_swig_abs_normal', tag, m, n, swchk, x, sigma, y, z, cz, cy, J, Y, Z, L, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`abs_normal`, 'returnType') = 'integer'
attr(`abs_normal`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'numeric', 'integer', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric')
class(`abs_normal`) = c("SWIGFunction", class('abs_normal'))

# Start of tape_doc

`tape_doc` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  
  
  ;.Call('R_swig_tape_doc', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, PACKAGE='autodiffadolc');
  
}

attr(`tape_doc`, 'returnType') = 'void'
attr(`tape_doc`, "inputTypes") = c('integer', 'integer', 'integer', 'numeric', 'numeric')
class(`tape_doc`) = c("SWIGFunction", class('tape_doc'))

# Start of jac_pat

`jac_pat` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  
  if (inherits(s_arg5, "ExternalReference")) s_arg5 = slot(s_arg5,"ref") 
  s_arg6 = as.integer(s_arg6);
  ;.Call('R_swig_jac_pat', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`jac_pat`, 'returnType') = 'integer'
attr(`jac_pat`, "inputTypes") = c('integer', 'integer', 'integer', 'numeric', '_p_p_unsigned_int', 'integer')
class(`jac_pat`) = c("SWIGFunction", class('jac_pat'))

# Start of absnormal_jac_pat

`absnormal_jac_pat` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  
  if (inherits(s_arg6, "ExternalReference")) s_arg6 = slot(s_arg6,"ref") 
  ;.Call('R_swig_absnormal_jac_pat', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`absnormal_jac_pat`, 'returnType') = 'integer'
attr(`absnormal_jac_pat`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'numeric', '_p_p_unsigned_int')
class(`absnormal_jac_pat`) = c("SWIGFunction", class('absnormal_jac_pat'))

# Start of generate_seed_jac

`generate_seed_jac` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  if (inherits(s_arg3, "ExternalReference")) s_arg3 = slot(s_arg3,"ref") 
  if (inherits(s_arg4, "ExternalReference")) s_arg4 = slot(s_arg4,"ref") 
  s_arg5 = as.integer(s_arg5);
  s_arg6 = as.integer(s_arg6);
  
  if(length(s_arg6) > 1) {
    warning("using only the first element of s_arg6");
  };
  
  ;.Call('R_swig_generate_seed_jac', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, PACKAGE='autodiffadolc');
  
}

attr(`generate_seed_jac`, 'returnType') = 'void'
attr(`generate_seed_jac`, "inputTypes") = c('integer', 'integer', '_p_p_unsigned_int', '_p_p_p_double', 'integer', 'integer')
class(`generate_seed_jac`) = c("SWIGFunction", class('generate_seed_jac'))

# Start of sparse_jac

`sparse_jac` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, s_arg9, s_arg10, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  s_arg4 = as.integer(s_arg4);
  
  if(length(s_arg4) > 1) {
    warning("using only the first element of s_arg4");
  };
  
  
  s_arg6 = as.integer(s_arg6);
  if (inherits(s_arg7, "ExternalReference")) s_arg7 = slot(s_arg7,"ref") 
  if (inherits(s_arg8, "ExternalReference")) s_arg8 = slot(s_arg8,"ref") 
  
  s_arg10 = as.integer(s_arg10);
  ;.Call('R_swig_sparse_jac', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, s_arg9, s_arg10, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`sparse_jac`, 'returnType') = 'integer'
attr(`sparse_jac`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'numeric', 'integer', '_p_p_unsigned_int', '_p_p_unsigned_int', 'numeric', 'integer')
class(`sparse_jac`) = c("SWIGFunction", class('sparse_jac'))

# Start of hess_pat

`hess_pat` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  
  if (inherits(s_arg4, "ExternalReference")) s_arg4 = slot(s_arg4,"ref") 
  s_arg5 = as.integer(s_arg5);
  
  if(length(s_arg5) > 1) {
    warning("using only the first element of s_arg5");
  };
  
  ;.Call('R_swig_hess_pat', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`hess_pat`, 'returnType') = 'integer'
attr(`hess_pat`, "inputTypes") = c('integer', 'integer', 'numeric', '_p_p_unsigned_int', 'integer')
class(`hess_pat`) = c("SWIGFunction", class('hess_pat'))

# Start of generate_seed_hess

`generate_seed_hess` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  if (inherits(s_arg3, "ExternalReference")) s_arg3 = slot(s_arg3,"ref") 
  s_arg4 = as.integer(s_arg4);
  s_arg5 = as.integer(s_arg5);
  
  if(length(s_arg5) > 1) {
    warning("using only the first element of s_arg5");
  };
  
  ;.Call('R_swig_generate_seed_hess', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, PACKAGE='autodiffadolc');
  
}

attr(`generate_seed_hess`, 'returnType') = 'void'
attr(`generate_seed_hess`, "inputTypes") = c('integer', '_p_p_unsigned_int', '_p_p_p_double', 'integer', 'integer')
class(`generate_seed_hess`) = c("SWIGFunction", class('generate_seed_hess'))

# Start of sparse_hess

`sparse_hess` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, s_arg9, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  
  s_arg5 = as.integer(s_arg5);
  if (inherits(s_arg6, "ExternalReference")) s_arg6 = slot(s_arg6,"ref") 
  if (inherits(s_arg7, "ExternalReference")) s_arg7 = slot(s_arg7,"ref") 
  
  s_arg9 = as.integer(s_arg9);
  ;.Call('R_swig_sparse_hess', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, s_arg7, s_arg8, s_arg9, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`sparse_hess`, 'returnType') = 'integer'
attr(`sparse_hess`, "inputTypes") = c('integer', 'integer', 'integer', 'numeric', 'integer', '_p_p_unsigned_int', '_p_p_unsigned_int', 'numeric', 'integer')
class(`sparse_hess`) = c("SWIGFunction", class('sparse_hess'))

# Start of set_HP

`set_HP` = function(tag, indep, HP)
{
  tag = as.integer(tag);
  
  if(length(tag) > 1) {
    warning("using only the first element of tag");
  };
  
  indep = as.integer(indep);
  
  if(length(indep) > 1) {
    warning("using only the first element of indep");
  };
  
  if (inherits(HP, "ExternalReference")) HP = slot(HP,"ref") 
  ;.Call('R_swig_set_HP', tag, indep, HP, PACKAGE='autodiffadolc');
  
}

attr(`set_HP`, 'returnType') = 'void'
attr(`set_HP`, "inputTypes") = c('integer', 'integer', '_p_p_unsigned_int')
class(`set_HP`) = c("SWIGFunction", class('set_HP'))

# Start of get_HP

`get_HP` = function(tag, indep, HP)
{
  tag = as.integer(tag);
  
  if(length(tag) > 1) {
    warning("using only the first element of tag");
  };
  
  indep = as.integer(indep);
  
  if(length(indep) > 1) {
    warning("using only the first element of indep");
  };
  
  if (inherits(HP, "ExternalReference")) HP = slot(HP,"ref") 
  ;.Call('R_swig_get_HP', tag, indep, HP, PACKAGE='autodiffadolc');
  
}

attr(`get_HP`, 'returnType') = 'void'
attr(`get_HP`, "inputTypes") = c('integer', 'integer', '_p_p_p_unsigned_int')
class(`get_HP`) = c("SWIGFunction", class('get_HP'))

# Start of bit_vector_propagation

`bit_vector_propagation` = function(s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, .copy = FALSE)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  
  if (inherits(s_arg5, "ExternalReference")) s_arg5 = slot(s_arg5,"ref") 
  s_arg6 = as.integer(s_arg6);
  ;.Call('R_swig_bit_vector_propagation', s_arg1, s_arg2, s_arg3, s_arg4, s_arg5, s_arg6, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`bit_vector_propagation`, 'returnType') = 'integer'
attr(`bit_vector_propagation`, "inputTypes") = c('integer', 'integer', 'integer', 'numeric', '_p_p_unsigned_int', 'integer')
class(`bit_vector_propagation`) = c("SWIGFunction", class('bit_vector_propagation'))

defineEnumeration('_StatEntries',
                    .values = c(
                        'NUM_INDEPENDENTS' = 0, 
                        'NUM_DEPENDENTS' = 1, 
                        'NUM_MAX_LIVES' = 2, 
                        'TAY_STACK_SIZE' = 3, 
                        'OP_BUFFER_SIZE' = 4, 
                        'NUM_OPERATIONS' = 5, 
                        'OP_FILE_ACCESS' = 6, 
                        'NUM_LOCATIONS' = 7, 
                        'LOC_FILE_ACCESS' = 8, 
                        'NUM_VALUES' = 9, 
                        'VAL_FILE_ACCESS' = 10, 
                        'LOC_BUFFER_SIZE' = 11, 
                        'VAL_BUFFER_SIZE' = 12, 
                        'TAY_BUFFER_SIZE' = 13, 
                        'NUM_EQ_PROD' = 14, 
                        'NO_MIN_MAX' = 15, 
                        'NUM_SWITCHES' = 16, 
                        'NUM_PARAM' = 17, 
                        'STAT_SIZE' = 18
))
defineEnumeration('_TapeRemovalType',
                    .values = c(
                        'ADOLC_REMOVE_FROM_CORE' = 0, 
                        'ADOLC_REMOVE_COMPLETELY' = 1
))
# Start of skip_tracefile_cleanup

`skip_tracefile_cleanup` = function(tnum)
{
  tnum = as.integer(tnum);
  
  if(length(tnum) > 1) {
    warning("using only the first element of tnum");
  };
  
  ;.Call('R_swig_skip_tracefile_cleanup', tnum, PACKAGE='autodiffadolc');
  
}

attr(`skip_tracefile_cleanup`, 'returnType') = 'void'
attr(`skip_tracefile_cleanup`, "inputTypes") = c('integer')
class(`skip_tracefile_cleanup`) = c("SWIGFunction", class('skip_tracefile_cleanup'))

# Start of tapestats

`tapestats` = function(tag, tape_stats)
{
  tag = as.integer(tag);
  
  if(length(tag) > 1) {
    warning("using only the first element of tag");
  };
  
  tape_stats = as.integer(tape_stats);
  ;.Call('R_swig_tapestats', tag, tape_stats, PACKAGE='autodiffadolc');
  
}

attr(`tapestats`, 'returnType') = 'void'
attr(`tapestats`, "inputTypes") = c('integer', 'integer')
class(`tapestats`) = c("SWIGFunction", class('tapestats'))

# Start of set_nested_ctx

`set_nested_ctx` = function(tag, nested)
{
  tag = as.integer(tag);
  
  if(length(tag) > 1) {
    warning("using only the first element of tag");
  };
  
  nested = as(nested, "character");     
  ;.Call('R_swig_set_nested_ctx', tag, nested, PACKAGE='autodiffadolc');
  
}

attr(`set_nested_ctx`, 'returnType') = 'void'
attr(`set_nested_ctx`, "inputTypes") = c('integer', 'character')
class(`set_nested_ctx`) = c("SWIGFunction", class('set_nested_ctx'))

# Start of printTapeStats

`printTapeStats` = function(stream, tag)
{
  if (inherits(stream, "ExternalReference")) stream = slot(stream,"ref") 
  tag = as.integer(tag);
  
  if(length(tag) > 1) {
    warning("using only the first element of tag");
  };
  
  ;.Call('R_swig_printTapeStats', stream, tag, PACKAGE='autodiffadolc');
  
}

attr(`printTapeStats`, 'returnType') = 'void'
attr(`printTapeStats`, "inputTypes") = c('_p_FILE', 'integer')
class(`printTapeStats`) = c("SWIGFunction", class('printTapeStats'))

# Start of removeTape

`removeTape` = function(tapeID, type, .copy = FALSE)
{
  tapeID = as.integer(tapeID);
  
  if(length(tapeID) > 1) {
    warning("using only the first element of tapeID");
  };
  
  type = as.integer(type);
  
  if(length(type) > 1) {
    warning("using only the first element of type");
  };
  
  ;.Call('R_swig_removeTape', tapeID, type, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`removeTape`, 'returnType') = 'integer'
attr(`removeTape`, "inputTypes") = c('integer', 'integer')
class(`removeTape`) = c("SWIGFunction", class('removeTape'))

# Start of enableBranchSwitchWarnings

`enableBranchSwitchWarnings` = function()
{
  ;.Call('R_swig_enableBranchSwitchWarnings', PACKAGE='autodiffadolc');
  
}

attr(`enableBranchSwitchWarnings`, 'returnType') = 'void'
class(`enableBranchSwitchWarnings`) = c("SWIGFunction", class('enableBranchSwitchWarnings'))

# Start of disableBranchSwitchWarnings

`disableBranchSwitchWarnings` = function()
{
  ;.Call('R_swig_disableBranchSwitchWarnings', PACKAGE='autodiffadolc');
  
}

attr(`disableBranchSwitchWarnings`, 'returnType') = 'void'
class(`disableBranchSwitchWarnings`) = c("SWIGFunction", class('disableBranchSwitchWarnings'))

# Start of enableMinMaxUsingAbs

`enableMinMaxUsingAbs` = function()
{
  ;.Call('R_swig_enableMinMaxUsingAbs', PACKAGE='autodiffadolc');
  
}

attr(`enableMinMaxUsingAbs`, 'returnType') = 'void'
class(`enableMinMaxUsingAbs`) = c("SWIGFunction", class('enableMinMaxUsingAbs'))

# Start of disableMinMaxUsingAbs

`disableMinMaxUsingAbs` = function()
{
  ;.Call('R_swig_disableMinMaxUsingAbs', PACKAGE='autodiffadolc');
  
}

attr(`disableMinMaxUsingAbs`, 'returnType') = 'void'
class(`disableMinMaxUsingAbs`) = c("SWIGFunction", class('disableMinMaxUsingAbs'))

# Start of setStoreManagerControl

`setStoreManagerControl` = function(gcTriggerRatio, gcTriggerMaxSize)
{
  gcTriggerMaxSize = as.integer(gcTriggerMaxSize);
  
  if(length(gcTriggerMaxSize) > 1) {
    warning("using only the first element of gcTriggerMaxSize");
  };
  
  ;.Call('R_swig_setStoreManagerControl', gcTriggerRatio, gcTriggerMaxSize, PACKAGE='autodiffadolc');
  
}

attr(`setStoreManagerControl`, 'returnType') = 'void'
attr(`setStoreManagerControl`, "inputTypes") = c('numeric', 'integer')
class(`setStoreManagerControl`) = c("SWIGFunction", class('setStoreManagerControl'))

# Start of initADOLC

`initADOLC` = function()
{
  ;.Call('R_swig_initADOLC', PACKAGE='autodiffadolc');
  
}

attr(`initADOLC`, 'returnType') = 'void'
class(`initADOLC`) = c("SWIGFunction", class('initADOLC'))

# Start of trace_on

`trace_on__SWIG_0` = function(tnum, keepTaylors, .copy = FALSE)
{
  tnum = as.integer(tnum);
  
  if(length(tnum) > 1) {
    warning("using only the first element of tnum");
  };
  
  keepTaylors = as.integer(keepTaylors);
  
  if(length(keepTaylors) > 1) {
    warning("using only the first element of keepTaylors");
  };
  
  ;.Call('R_swig_trace_on__SWIG_0', tnum, keepTaylors, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`trace_on__SWIG_0`, 'returnType') = 'integer'
attr(`trace_on__SWIG_0`, "inputTypes") = c('integer', 'integer')
class(`trace_on__SWIG_0`) = c("SWIGFunction", class('trace_on__SWIG_0'))

# Start of trace_on

`trace_on__SWIG_1` = function(tnum, .copy = FALSE)
{
  tnum = as.integer(tnum);
  
  if(length(tnum) > 1) {
    warning("using only the first element of tnum");
  };
  
  ;.Call('R_swig_trace_on__SWIG_1', tnum, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`trace_on__SWIG_1`, 'returnType') = 'integer'
attr(`trace_on__SWIG_1`, "inputTypes") = c('integer')
class(`trace_on__SWIG_1`) = c("SWIGFunction", class('trace_on__SWIG_1'))

# Start of trace_on

`trace_on__SWIG_2` = function(tnum, keepTaylors, obs, lbs, vbs, tbs, skipFileCleanup, .copy = FALSE)
{
  tnum = as.integer(tnum);
  
  if(length(tnum) > 1) {
    warning("using only the first element of tnum");
  };
  
  keepTaylors = as.integer(keepTaylors);
  
  if(length(keepTaylors) > 1) {
    warning("using only the first element of keepTaylors");
  };
  
  obs = as.integer(obs);
  
  if(length(obs) > 1) {
    warning("using only the first element of obs");
  };
  
  lbs = as.integer(lbs);
  
  if(length(lbs) > 1) {
    warning("using only the first element of lbs");
  };
  
  vbs = as.integer(vbs);
  
  if(length(vbs) > 1) {
    warning("using only the first element of vbs");
  };
  
  tbs = as.integer(tbs);
  
  if(length(tbs) > 1) {
    warning("using only the first element of tbs");
  };
  
  skipFileCleanup = as.integer(skipFileCleanup);
  
  if(length(skipFileCleanup) > 1) {
    warning("using only the first element of skipFileCleanup");
  };
  
  ;.Call('R_swig_trace_on__SWIG_2', tnum, keepTaylors, obs, lbs, vbs, tbs, skipFileCleanup, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`trace_on__SWIG_2`, 'returnType') = 'integer'
attr(`trace_on__SWIG_2`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'integer', 'integer', 'integer')
class(`trace_on__SWIG_2`) = c("SWIGFunction", class('trace_on__SWIG_2'))

# Start of trace_on

`trace_on__SWIG_3` = function(tnum, keepTaylors, obs, lbs, vbs, tbs, .copy = FALSE)
{
  tnum = as.integer(tnum);
  
  if(length(tnum) > 1) {
    warning("using only the first element of tnum");
  };
  
  keepTaylors = as.integer(keepTaylors);
  
  if(length(keepTaylors) > 1) {
    warning("using only the first element of keepTaylors");
  };
  
  obs = as.integer(obs);
  
  if(length(obs) > 1) {
    warning("using only the first element of obs");
  };
  
  lbs = as.integer(lbs);
  
  if(length(lbs) > 1) {
    warning("using only the first element of lbs");
  };
  
  vbs = as.integer(vbs);
  
  if(length(vbs) > 1) {
    warning("using only the first element of vbs");
  };
  
  tbs = as.integer(tbs);
  
  if(length(tbs) > 1) {
    warning("using only the first element of tbs");
  };
  
  ;.Call('R_swig_trace_on__SWIG_3', tnum, keepTaylors, obs, lbs, vbs, tbs, as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`trace_on__SWIG_3`, 'returnType') = 'integer'
attr(`trace_on__SWIG_3`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', 'integer', 'integer')
class(`trace_on__SWIG_3`) = c("SWIGFunction", class('trace_on__SWIG_3'))

#' Start of the ADOL-C taping process
#'
#' \code{trace_on} starts the \code{autodiffadolc} tracing process. Using 
#' \code{autodiffadolc} consists of two phases (1) Tracing (also called taping), 
#' generally performed once and (2) Computation of derivatives, which can be performed. 
#' \code{trace_on} is the initialization for the taping process. Creates buffers 
#' for this tape, sets files names, and calls appropriate setup routines.
#'
#' @param tag integer to identify the trace that is created
#'
#' @return None
#'
#' @examples
#' trace_on(1)
#'
#'@seealso{\code{\link{trace_off}}, \code{\link{badouble_declareIndependent}}, 
#'         \code{\link{badouble_declareDependent}}}
#'         
#'@keywords{autodiffadolc}
#'
#' @export

`trace_on` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- trace_on__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- trace_on__SWIG_0; 
    }
  } else if (argc == 6) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 ) && ( (is.integer(argv[[6]]) || is.numeric(argv[[6]])) && length(argv[[6]]) == 1 )) {
      f <- trace_on__SWIG_3; 
    }
  } else if (argc == 7) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 ) && ( (is.integer(argv[[6]]) || is.numeric(argv[[6]])) && length(argv[[6]]) == 1 ) && ( (is.integer(argv[[7]]) || is.numeric(argv[[7]])) && length(argv[[7]]) == 1 )) {
      f <- trace_on__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for trace_on with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of trace_off

`trace_off__SWIG_0` = function(flag)
{
  flag = as.integer(flag);
  
  if(length(flag) > 1) {
    warning("using only the first element of flag");
  };
  
  ;.Call('R_swig_trace_off__SWIG_0', flag, PACKAGE='autodiffadolc');
  
}

attr(`trace_off__SWIG_0`, 'returnType') = 'void'
attr(`trace_off__SWIG_0`, "inputTypes") = c('integer')
class(`trace_off__SWIG_0`) = c("SWIGFunction", class('trace_off__SWIG_0'))

# Start of trace_off

`trace_off__SWIG_1` = function()
{
  ;.Call('R_swig_trace_off__SWIG_1', PACKAGE='autodiffadolc');
  
}

attr(`trace_off__SWIG_1`, 'returnType') = 'void'
class(`trace_off__SWIG_1`) = c("SWIGFunction", class('trace_off__SWIG_1'))

#' Stop Tracing
#'
#' \code{trace_off} ends the \code{autodiffadolc} tracing process. Using 
#' Using \code{autodiffadolc} consists of two phases (1) Tracing 
#' (also called taping), generally performed once and (2) Computation of 
#' derivatives, which can be performed. \code{trace_off} marks where 
#' the taping ends.  Cleans up, and turns off trace_flag.
#'
#' @return None
#'
#' @examples
#' trace_off()
#'
#'@seealso{\code{\link{trace_on}}, \code{\link{badouble_declareIndependent}}, 
#'         \code{\link{badouble_declareDependent}}}
#'
#'@keywords{autodiffadolc}
#'
#'  @export

`trace_off` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- trace_off__SWIG_1; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- trace_off__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for trace_off with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of isTaping

`isTaping` = function(.copy = FALSE)
{
  ;.Call('R_swig_isTaping', as.logical(.copy), PACKAGE='autodiffadolc');
  
}

attr(`isTaping`, 'returnType') = 'logical'
class(`isTaping`) = c("SWIGFunction", class('isTaping'))

# Start of cachedTraceTags

`cachedTraceTags` = function(result)
{
  if (inherits(result, "ExternalReference")) result = slot(result,"ref") 
  ;.Call('R_swig_cachedTraceTags', result, PACKAGE='autodiffadolc');
  
}

attr(`cachedTraceTags`, 'returnType') = 'void'
attr(`cachedTraceTags`, "inputTypes") = c('_p_std__vectorT_short_t')
class(`cachedTraceTags`) = c("SWIGFunction", class('cachedTraceTags'))

# Start of populate_dpp

`populate_dpp` = function(pointer, memory, n, m)
{
  if (inherits(pointer, "ExternalReference")) pointer = slot(pointer,"ref") 
  memory = as(memory, "character"); 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  m = as.integer(m);
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  ;.Call('R_swig_populate_dpp', pointer, memory, n, m, PACKAGE='autodiffadolc');
  
}

attr(`populate_dpp`, 'returnType') = 'character'
attr(`populate_dpp`, "inputTypes") = c('_p_p_p_double', 'character', 'integer', 'integer')
class(`populate_dpp`) = c("SWIGFunction", class('populate_dpp'))

# Start of populate_dppp

`populate_dppp` = function(pointer, memory, n, m, p)
{
  if (inherits(pointer, "ExternalReference")) pointer = slot(pointer,"ref") 
  memory = as(memory, "character"); 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  m = as.integer(m);
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  p = as.integer(p);
  
  if(length(p) > 1) {
    warning("using only the first element of p");
  };
  
  ;.Call('R_swig_populate_dppp', pointer, memory, n, m, p, PACKAGE='autodiffadolc');
  
}

attr(`populate_dppp`, 'returnType') = 'character'
attr(`populate_dppp`, "inputTypes") = c('_p_p_p_p_double', 'character', 'integer', 'integer', 'integer')
class(`populate_dppp`) = c("SWIGFunction", class('populate_dppp'))

# Start of populate_dppp_nodata

`populate_dppp_nodata` = function(pointer, memory, n, m)
{
  if (inherits(pointer, "ExternalReference")) pointer = slot(pointer,"ref") 
  memory = as(memory, "character"); 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  m = as.integer(m);
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  ;.Call('R_swig_populate_dppp_nodata', pointer, memory, n, m, PACKAGE='autodiffadolc');
  
}

attr(`populate_dppp_nodata`, 'returnType') = 'character'
attr(`populate_dppp_nodata`, "inputTypes") = c('_p_p_p_p_double', 'character', 'integer', 'integer')
class(`populate_dppp_nodata`) = c("SWIGFunction", class('populate_dppp_nodata'))

# Start of myalloc1

`myalloc1` = function(s_arg1)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  ;.Call('R_swig_myalloc1', s_arg1, PACKAGE='autodiffadolc');
  
}

attr(`myalloc1`, 'returnType') = 'numeric'
attr(`myalloc1`, "inputTypes") = c('integer')
class(`myalloc1`) = c("SWIGFunction", class('myalloc1'))

# Start of myalloc2

`myalloc2` = function(s_arg1, s_arg2)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  ;.Call('R_swig_myalloc2', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  
}

attr(`myalloc2`, 'returnType') = 'numeric'
attr(`myalloc2`, "inputTypes") = c('integer', 'integer')
class(`myalloc2`) = c("SWIGFunction", class('myalloc2'))

# Start of myalloc3

`myalloc3` = function(s_arg1, s_arg2, s_arg3)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  s_arg3 = as.integer(s_arg3);
  
  if(length(s_arg3) > 1) {
    warning("using only the first element of s_arg3");
  };
  
  ;ans = .Call('R_swig_myalloc3', s_arg1, s_arg2, s_arg3, PACKAGE='autodiffadolc');
  ans <- new("_p_p_p_double", ref=ans) ;
  
  ans
  
}

attr(`myalloc3`, 'returnType') = '_p_p_p_double'
attr(`myalloc3`, "inputTypes") = c('integer', 'integer', 'integer')
class(`myalloc3`) = c("SWIGFunction", class('myalloc3'))

# Start of myfree1

`myfree1` = function(s_arg1)
{
  ;.Call('R_swig_myfree1', s_arg1, PACKAGE='autodiffadolc');
  
}

attr(`myfree1`, 'returnType') = 'void'
attr(`myfree1`, "inputTypes") = c('numeric')
class(`myfree1`) = c("SWIGFunction", class('myfree1'))

# Start of myfree2

`myfree2` = function(s_arg1)
{
  ;.Call('R_swig_myfree2', s_arg1, PACKAGE='autodiffadolc');
  
}

attr(`myfree2`, 'returnType') = 'void'
attr(`myfree2`, "inputTypes") = c('numeric')
class(`myfree2`) = c("SWIGFunction", class('myfree2'))

# Start of myfree3

`myfree3` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;.Call('R_swig_myfree3', s_arg1, PACKAGE='autodiffadolc');
  
}

attr(`myfree3`, 'returnType') = 'void'
attr(`myfree3`, "inputTypes") = c('_p_p_p_double')
class(`myfree3`) = c("SWIGFunction", class('myfree3'))

# Start of myallocI2

`myallocI2` = function(s_arg1)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  ;.Call('R_swig_myallocI2', s_arg1, PACKAGE='autodiffadolc');
  
}

attr(`myallocI2`, 'returnType') = 'numeric'
attr(`myallocI2`, "inputTypes") = c('integer')
class(`myallocI2`) = c("SWIGFunction", class('myallocI2'))

# Start of myfreeI2

`myfreeI2` = function(s_arg1, s_arg2)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  
  ;.Call('R_swig_myfreeI2', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  
}

attr(`myfreeI2`, 'returnType') = 'void'
attr(`myfreeI2`, "inputTypes") = c('integer', 'numeric')
class(`myfreeI2`) = c("SWIGFunction", class('myfreeI2'))

# Start of myalloc1_uint

`myalloc1_uint` = function(s_arg1)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  ;ans = .Call('R_swig_myalloc1_uint', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_unsigned_int", ref=ans) ;
  
  ans
  
}

attr(`myalloc1_uint`, 'returnType') = 'integer'
attr(`myalloc1_uint`, "inputTypes") = c('integer')
class(`myalloc1_uint`) = c("SWIGFunction", class('myalloc1_uint'))

# Start of myalloc1_ulong

`myalloc1_ulong` = function(s_arg1)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  ;ans = .Call('R_swig_myalloc1_ulong', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_unsigned_long", ref=ans) ;
  
  ans
  
}

attr(`myalloc1_ulong`, 'returnType') = 'integer'
attr(`myalloc1_ulong`, "inputTypes") = c('integer')
class(`myalloc1_ulong`) = c("SWIGFunction", class('myalloc1_ulong'))

# Start of myalloc2_ulong

`myalloc2_ulong` = function(s_arg1, s_arg2)
{
  s_arg1 = as.integer(s_arg1);
  
  if(length(s_arg1) > 1) {
    warning("using only the first element of s_arg1");
  };
  
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  ;ans = .Call('R_swig_myalloc2_ulong', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_p_unsigned_long", ref=ans) ;
  
  ans
  
}

attr(`myalloc2_ulong`, 'returnType') = '_p_p_unsigned_long'
attr(`myalloc2_ulong`, "inputTypes") = c('integer', 'integer')
class(`myalloc2_ulong`) = c("SWIGFunction", class('myalloc2_ulong'))

# Start of myfree1_uint

`myfree1_uint` = function(s_arg1)
{
  s_arg1 = as.integer(s_arg1);
  ;.Call('R_swig_myfree1_uint', s_arg1, PACKAGE='autodiffadolc');
  
}

attr(`myfree1_uint`, 'returnType') = 'void'
attr(`myfree1_uint`, "inputTypes") = c('integer')
class(`myfree1_uint`) = c("SWIGFunction", class('myfree1_uint'))

# Start of myfree1_ulong

`myfree1_ulong` = function(s_arg1)
{
  s_arg1 = as.integer(s_arg1);
  ;.Call('R_swig_myfree1_ulong', s_arg1, PACKAGE='autodiffadolc');
  
}

attr(`myfree1_ulong`, 'returnType') = 'void'
attr(`myfree1_ulong`, "inputTypes") = c('integer')
class(`myfree1_ulong`) = c("SWIGFunction", class('myfree1_ulong'))

# Start of myfree2_ulong

`myfree2_ulong` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;.Call('R_swig_myfree2_ulong', s_arg1, PACKAGE='autodiffadolc');
  
}

attr(`myfree2_ulong`, 'returnType') = 'void'
attr(`myfree2_ulong`, "inputTypes") = c('_p_p_unsigned_long')
class(`myfree2_ulong`) = c("SWIGFunction", class('myfree2_ulong'))

# Start of myalloc

`myalloc__SWIG_0` = function(n)
{
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_myalloc__SWIG_0', n, PACKAGE='autodiffadolc');
  
}

attr(`myalloc__SWIG_0`, 'returnType') = 'numeric'
attr(`myalloc__SWIG_0`, "inputTypes") = c('integer')
class(`myalloc__SWIG_0`) = c("SWIGFunction", class('myalloc__SWIG_0'))

# Start of myalloc

`myalloc__SWIG_1` = function(m, n)
{
  m = as.integer(m);
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_myalloc__SWIG_1', m, n, PACKAGE='autodiffadolc');
  
}

attr(`myalloc__SWIG_1`, 'returnType') = 'numeric'
attr(`myalloc__SWIG_1`, "inputTypes") = c('integer', 'integer')
class(`myalloc__SWIG_1`) = c("SWIGFunction", class('myalloc__SWIG_1'))

# Start of myalloc

`myalloc__SWIG_2` = function(m, n, p)
{
  m = as.integer(m);
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  p = as.integer(p);
  
  if(length(p) > 1) {
    warning("using only the first element of p");
  };
  
  ;ans = .Call('R_swig_myalloc__SWIG_2', m, n, p, PACKAGE='autodiffadolc');
  ans <- new("_p_p_p_double", ref=ans) ;
  
  ans
  
}

attr(`myalloc__SWIG_2`, 'returnType') = '_p_p_p_double'
attr(`myalloc__SWIG_2`, "inputTypes") = c('integer', 'integer', 'integer')
class(`myalloc__SWIG_2`) = c("SWIGFunction", class('myalloc__SWIG_2'))

`myalloc` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- myalloc__SWIG_0; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- myalloc__SWIG_1; 
    }
  } else if (argc == 3) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 )) {
      f <- myalloc__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for myalloc with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of myfree

`myfree__SWIG_0` = function(A)
{
  ;.Call('R_swig_myfree__SWIG_0', A, PACKAGE='autodiffadolc');
  
}

attr(`myfree__SWIG_0`, 'returnType') = 'void'
attr(`myfree__SWIG_0`, "inputTypes") = c('numeric')
class(`myfree__SWIG_0`) = c("SWIGFunction", class('myfree__SWIG_0'))

# Start of myfree

`myfree__SWIG_1` = function(A)
{
  ;.Call('R_swig_myfree__SWIG_1', A, PACKAGE='autodiffadolc');
  
}

attr(`myfree__SWIG_1`, 'returnType') = 'void'
attr(`myfree__SWIG_1`, "inputTypes") = c('numeric')
class(`myfree__SWIG_1`) = c("SWIGFunction", class('myfree__SWIG_1'))

# Start of myfree

`myfree__SWIG_2` = function(A)
{
  if (inherits(A, "ExternalReference")) A = slot(A,"ref") 
  ;.Call('R_swig_myfree__SWIG_2', A, PACKAGE='autodiffadolc');
  
}

attr(`myfree__SWIG_2`, 'returnType') = 'void'
attr(`myfree__SWIG_2`, "inputTypes") = c('_p_p_p_double')
class(`myfree__SWIG_2`) = c("SWIGFunction", class('myfree__SWIG_2'))

`myfree` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 1) {
    if (extends(argtypes[1], '_p_p_p_double')) {
      f <- myfree__SWIG_2; 
    }
    else if (( is.numeric(argv[[1]]) )) {
      f <- myfree__SWIG_1; 
    }
    else if (( is.numeric(argv[[1]]) )) {
      f <- myfree__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for myfree with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Plus

`Plus__SWIG_0` = function(x)
{
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;ans = .Call('R_swig_Plus__SWIG_0', x, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`Plus__SWIG_0`, 'returnType') = '_p_adub'
attr(`Plus__SWIG_0`, "inputTypes") = c('_p_badouble')
class(`Plus__SWIG_0`) = c("SWIGFunction", class('Plus__SWIG_0'))

# Start of Minus

`Minus__SWIG_0` = function(x)
{
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;ans = .Call('R_swig_Minus__SWIG_0', x, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`Minus__SWIG_0`, 'returnType') = '_p_adub'
attr(`Minus__SWIG_0`, "inputTypes") = c('_p_badouble')
class(`Minus__SWIG_0`) = c("SWIGFunction", class('Minus__SWIG_0'))

# Start of Minus

`Minus__SWIG_1` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_Minus__SWIG_1', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`Minus__SWIG_1`, 'returnType') = '_p_adub'
attr(`Minus__SWIG_1`, "inputTypes") = c('_p_pdouble')
class(`Minus__SWIG_1`) = c("SWIGFunction", class('Minus__SWIG_1'))

# Start of Plus

`Plus__SWIG_1` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_Plus__SWIG_1', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`Plus__SWIG_1`, 'returnType') = '_p_adub'
attr(`Plus__SWIG_1`, "inputTypes") = c('_p_badouble', '_p_badouble')
class(`Plus__SWIG_1`) = c("SWIGFunction", class('Plus__SWIG_1'))

# Start of Plus

`Plus__SWIG_2` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_Plus__SWIG_2', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`Plus__SWIG_2`, 'returnType') = '_p_adub'
attr(`Plus__SWIG_2`, "inputTypes") = c('numeric', '_p_badouble')
class(`Plus__SWIG_2`) = c("SWIGFunction", class('Plus__SWIG_2'))

# Start of Plus

`Plus__SWIG_3` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  
  ;ans = .Call('R_swig_Plus__SWIG_3', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`Plus__SWIG_3`, 'returnType') = '_p_adub'
attr(`Plus__SWIG_3`, "inputTypes") = c('_p_badouble', 'numeric')
class(`Plus__SWIG_3`) = c("SWIGFunction", class('Plus__SWIG_3'))

# Start of Minus

`Minus__SWIG_2` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_Minus__SWIG_2', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`Minus__SWIG_2`, 'returnType') = '_p_adub'
attr(`Minus__SWIG_2`, "inputTypes") = c('_p_badouble', '_p_badouble')
class(`Minus__SWIG_2`) = c("SWIGFunction", class('Minus__SWIG_2'))

# Start of Minus

`Minus__SWIG_3` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  
  ;ans = .Call('R_swig_Minus__SWIG_3', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`Minus__SWIG_3`, 'returnType') = '_p_adub'
attr(`Minus__SWIG_3`, "inputTypes") = c('_p_badouble', 'numeric')
class(`Minus__SWIG_3`) = c("SWIGFunction", class('Minus__SWIG_3'))

# Start of Minus

`Minus__SWIG_4` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_Minus__SWIG_4', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`Minus__SWIG_4`, 'returnType') = '_p_adub'
attr(`Minus__SWIG_4`, "inputTypes") = c('numeric', '_p_badouble')
class(`Minus__SWIG_4`) = c("SWIGFunction", class('Minus__SWIG_4'))

# Start of Multiply

`Multiply__SWIG_0` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_Multiply__SWIG_0', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`Multiply__SWIG_0`, 'returnType') = '_p_adub'
attr(`Multiply__SWIG_0`, "inputTypes") = c('_p_badouble', '_p_badouble')
class(`Multiply__SWIG_0`) = c("SWIGFunction", class('Multiply__SWIG_0'))

# Start of Multiply

`Multiply__SWIG_1` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_Multiply__SWIG_1', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`Multiply__SWIG_1`, 'returnType') = '_p_adub'
attr(`Multiply__SWIG_1`, "inputTypes") = c('numeric', '_p_badouble')
class(`Multiply__SWIG_1`) = c("SWIGFunction", class('Multiply__SWIG_1'))

# Start of Multiply

`Multiply__SWIG_2` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  
  ;ans = .Call('R_swig_Multiply__SWIG_2', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`Multiply__SWIG_2`, 'returnType') = '_p_adub'
attr(`Multiply__SWIG_2`, "inputTypes") = c('_p_badouble', 'numeric')
class(`Multiply__SWIG_2`) = c("SWIGFunction", class('Multiply__SWIG_2'))

# Start of Divide

`Divide__SWIG_0` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  
  ;ans = .Call('R_swig_Divide__SWIG_0', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`Divide__SWIG_0`, 'returnType') = '_p_adub'
attr(`Divide__SWIG_0`, "inputTypes") = c('_p_badouble', 'numeric')
class(`Divide__SWIG_0`) = c("SWIGFunction", class('Divide__SWIG_0'))

# Start of Divide

`Divide__SWIG_1` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_Divide__SWIG_1', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`Divide__SWIG_1`, 'returnType') = '_p_adub'
attr(`Divide__SWIG_1`, "inputTypes") = c('_p_badouble', '_p_badouble')
class(`Divide__SWIG_1`) = c("SWIGFunction", class('Divide__SWIG_1'))

# Start of Divide

`Divide__SWIG_2` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_Divide__SWIG_2', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`Divide__SWIG_2`, 'returnType') = '_p_adub'
attr(`Divide__SWIG_2`, "inputTypes") = c('numeric', '_p_badouble')
class(`Divide__SWIG_2`) = c("SWIGFunction", class('Divide__SWIG_2'))

# Start of Plus

`Plus__SWIG_4` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_Plus__SWIG_4', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`Plus__SWIG_4`, 'returnType') = '_p_adub'
attr(`Plus__SWIG_4`, "inputTypes") = c('_p_pdouble', '_p_badouble')
class(`Plus__SWIG_4`) = c("SWIGFunction", class('Plus__SWIG_4'))

# Start of Plus

`Plus__SWIG_5` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  
  ;ans = .Call('R_swig_Plus__SWIG_5', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`Plus__SWIG_5`, 'returnType') = '_p_adub'
attr(`Plus__SWIG_5`, "inputTypes") = c('_p_pdouble', 'numeric')
class(`Plus__SWIG_5`) = c("SWIGFunction", class('Plus__SWIG_5'))

# Start of Plus

`Plus__SWIG_6` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_Plus__SWIG_6', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`Plus__SWIG_6`, 'returnType') = '_p_adub'
attr(`Plus__SWIG_6`, "inputTypes") = c('numeric', '_p_pdouble')
class(`Plus__SWIG_6`) = c("SWIGFunction", class('Plus__SWIG_6'))

# Start of Plus

`Plus__SWIG_7` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_Plus__SWIG_7', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`Plus__SWIG_7`, 'returnType') = '_p_adub'
attr(`Plus__SWIG_7`, "inputTypes") = c('_p_badouble', '_p_pdouble')
class(`Plus__SWIG_7`) = c("SWIGFunction", class('Plus__SWIG_7'))

`oldplus` <- `+`

`+` <- function(...) {
  argtypes <- get_argtype(...);
  argv <- list(...);
  argc <- length(argtypes);
  if (argc == 2) {
      if (!extends(argtypes[1], '_p_badouble') && !extends(argtypes[1], '_p_pdouble')
      && !extends(argtypes[2], '_p_badouble') && !extends(argtypes[2], '_p_pdouble')) {
          ans <- oldplus(argv[[1]],argv[[2]]);
          return(ans);
      }
  }
# dispatch functions 8
  if (argc == 1) {
    if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1) {
      f <- Plus__SWIG_0; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_badouble') && extends(argtypes[2], '_p_badouble')) {
      f <- Plus__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_badouble') && extends(argtypes[2], '_p_pdouble')) {
      f <- Plus__SWIG_7; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && extends(argtypes[2], '_p_badouble')) {
      f <- Plus__SWIG_4; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && (is.numeric(argv[[2]]) )) {
      f <- Plus__SWIG_5; 
    }
    else if (extends(argtypes[1], '_p_badouble') && (is.numeric(argv[[2]]) )) {
      f <- Plus__SWIG_3; 
    }
    else if ((is.numeric(argv[[1]]) ) && extends(argtypes[2], '_p_pdouble')) {
      f <- Plus__SWIG_6; 
    }
    else if ((is.numeric(argv[[1]]) ) && extends(argtypes[2], '_p_badouble')) {
      f <- Plus__SWIG_2; 
    } else {
        f <- oldplus;
    }
  } else {
      f <- oldplus;
  };
  return(adolc_operator_dispatch(..., f=f))
}

# Dispatch function
# Start of Minus

`Minus__SWIG_5` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_Minus__SWIG_5', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`Minus__SWIG_5`, 'returnType') = '_p_adub'
attr(`Minus__SWIG_5`, "inputTypes") = c('_p_badouble', '_p_pdouble')
class(`Minus__SWIG_5`) = c("SWIGFunction", class('Minus__SWIG_5'))

# Start of Minus

`Minus__SWIG_6` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  
  ;ans = .Call('R_swig_Minus__SWIG_6', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`Minus__SWIG_6`, 'returnType') = '_p_adub'
attr(`Minus__SWIG_6`, "inputTypes") = c('_p_pdouble', 'numeric')
class(`Minus__SWIG_6`) = c("SWIGFunction", class('Minus__SWIG_6'))

# Start of Minus

`Minus__SWIG_7` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_Minus__SWIG_7', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`Minus__SWIG_7`, 'returnType') = '_p_adub'
attr(`Minus__SWIG_7`, "inputTypes") = c('numeric', '_p_pdouble')
class(`Minus__SWIG_7`) = c("SWIGFunction", class('Minus__SWIG_7'))

# Start of Minus

`Minus__SWIG_8` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_Minus__SWIG_8', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`Minus__SWIG_8`, 'returnType') = '_p_adub'
attr(`Minus__SWIG_8`, "inputTypes") = c('_p_pdouble', '_p_badouble')
class(`Minus__SWIG_8`) = c("SWIGFunction", class('Minus__SWIG_8'))

`oldminus` <- `-`

`-` <- function(...) {
  argtypes <- get_argtype(...);
  argv <- list(...);
  argc <- length(argtypes);
  if (argc == 2) {
      if (!extends(argtypes[1], '_p_badouble') && !extends(argtypes[1], '_p_pdouble')
      && !extends(argtypes[2], '_p_badouble') && !extends(argtypes[2], '_p_pdouble')) {
          ans <- oldminus(argv[[1]],argv[[2]]);
          return(ans);
      }
  }
# dispatch functions 9
  if (argc == 1) {
    if (extends(argtypes[1], '_p_badouble')) {
      f <- Minus__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_pdouble')) {
      f <- Minus__SWIG_1; 
    } else {
        f <- oldminus;
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_badouble') && extends(argtypes[2], '_p_badouble')) {
      f <- Minus__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_badouble') && extends(argtypes[2], '_p_pdouble')) {
      f <- Minus__SWIG_5; 
    }
    else if (extends(argtypes[1], '_p_badouble') && is.numeric(argv[[2]])) {
      f <- Minus__SWIG_3; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && extends(argtypes[2], '_p_badouble')) {
      f <- Minus__SWIG_8; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && is.numeric(argv[[2]])) {
      f <- Minus__SWIG_6; 
    }
    else if (is.numeric(argv[[1]]) && extends(argtypes[2], '_p_pdouble')) {
      f <- Minus__SWIG_7; 
    }
    else if (is.numeric(argv[[1]]) && extends(argtypes[2], '_p_badouble')) {
      f <- Minus__SWIG_4; 
    } else {
        f <- oldminus;
    }
  } else {
      f <- oldminus;
  };
  return(adolc_operator_dispatch(..., f=f))
}


# Dispatch function
# Start of Multiply

`Multiply__SWIG_3` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_Multiply__SWIG_3', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`Multiply__SWIG_3`, 'returnType') = '_p_adub'
attr(`Multiply__SWIG_3`, "inputTypes") = c('_p_badouble', '_p_pdouble')
class(`Multiply__SWIG_3`) = c("SWIGFunction", class('Multiply__SWIG_3'))

# Start of Multiply

`Multiply__SWIG_4` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_Multiply__SWIG_4', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`Multiply__SWIG_4`, 'returnType') = '_p_adub'
attr(`Multiply__SWIG_4`, "inputTypes") = c('_p_pdouble', '_p_badouble')
class(`Multiply__SWIG_4`) = c("SWIGFunction", class('Multiply__SWIG_4'))

# Start of Multiply

`Multiply__SWIG_5` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  
  ;ans = .Call('R_swig_Multiply__SWIG_5', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`Multiply__SWIG_5`, 'returnType') = '_p_adub'
attr(`Multiply__SWIG_5`, "inputTypes") = c('_p_pdouble', 'numeric')
class(`Multiply__SWIG_5`) = c("SWIGFunction", class('Multiply__SWIG_5'))

# Start of Multiply

`Multiply__SWIG_6` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_Multiply__SWIG_6', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`Multiply__SWIG_6`, 'returnType') = '_p_adub'
attr(`Multiply__SWIG_6`, "inputTypes") = c('numeric', '_p_pdouble')
class(`Multiply__SWIG_6`) = c("SWIGFunction", class('Multiply__SWIG_6'))

`oldmultiply` <- `*`

`*` <- function(...) {
  argtypes <- get_argtype(...);
  argv <- list(...);
  argc <- length(argtypes);
  if (argc == 2) {
      if (!extends(argtypes[1], '_p_badouble') && !extends(argtypes[1], '_p_pdouble')
      && !extends(argtypes[2], '_p_badouble') && !extends(argtypes[2], '_p_pdouble')) {
          ans <- oldmultiply(argv[[1]],argv[[2]]);
          return(ans);
      }
  }
# dispatch functions 7
  if (argc == 2) {
    if (extends(argtypes[1], '_p_badouble') && extends(argtypes[2], '_p_badouble')) {
      f <- Multiply__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_badouble') && extends(argtypes[2], '_p_pdouble')) {
      f <- Multiply__SWIG_3; 
    }
    else if (extends(argtypes[1], '_p_badouble') && is.numeric(argv[[2]])) {
      f <- Multiply__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && extends(argtypes[2], '_p_badouble')) {
      f <- Multiply__SWIG_4; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && is.numeric(argv[[2]])) {
      f <- Multiply__SWIG_5; 
    }
    else if (is.numeric(argv[[1]]) && extends(argtypes[2], '_p_badouble')) {
      f <- Multiply__SWIG_1; 
    }
    else if (is.numeric(argv[[1]]) && extends(argtypes[2], '_p_pdouble')) {
      f <- Multiply__SWIG_6; 
    } else {
        f <- oldmultiply;
    }
  } else {
      f <- oldmultiply;
  };
  return(adolc_operator_dispatch(..., f=f))
}


# Dispatch function
# Start of recipr

`recipr` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_recipr', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`recipr`, 'returnType') = '_p_adub'
attr(`recipr`, "inputTypes") = c('_p_pdouble')
class(`recipr`) = c("SWIGFunction", class('recipr'))

# Start of Divide

`Divide__SWIG_3` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_Divide__SWIG_3', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`Divide__SWIG_3`, 'returnType') = '_p_adub'
attr(`Divide__SWIG_3`, "inputTypes") = c('_p_badouble', '_p_pdouble')
class(`Divide__SWIG_3`) = c("SWIGFunction", class('Divide__SWIG_3'))

# Start of Divide

`Divide__SWIG_4` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_Divide__SWIG_4', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`Divide__SWIG_4`, 'returnType') = '_p_adub'
attr(`Divide__SWIG_4`, "inputTypes") = c('numeric', '_p_pdouble')
class(`Divide__SWIG_4`) = c("SWIGFunction", class('Divide__SWIG_4'))

# Start of Divide

`Divide__SWIG_5` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  
  ;ans = .Call('R_swig_Divide__SWIG_5', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`Divide__SWIG_5`, 'returnType') = '_p_adub'
attr(`Divide__SWIG_5`, "inputTypes") = c('_p_pdouble', 'numeric')
class(`Divide__SWIG_5`) = c("SWIGFunction", class('Divide__SWIG_5'))

# Start of Divide

`Divide__SWIG_6` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_Divide__SWIG_6', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`Divide__SWIG_6`, 'returnType') = '_p_adub'
attr(`Divide__SWIG_6`, "inputTypes") = c('_p_pdouble', '_p_badouble')
class(`Divide__SWIG_6`) = c("SWIGFunction", class('Divide__SWIG_6'))

`olddivide` <- `/`

`/` <- function(...) {
  argtypes <- get_argtype(...);
  argv <- list(...);
  argc <- length(argtypes);
  if (argc == 2) {
      if (!extends(argtypes[1], '_p_badouble') && !extends(argtypes[1], '_p_pdouble')
      && !extends(argtypes[2], '_p_badouble') && !extends(argtypes[2], '_p_pdouble')) {
          ans <- olddivide(argv[[1]],argv[[2]]);
          return(ans);
      }
  }
# dispatch functions 7
  if (argc == 2) {
    if (extends(argtypes[1], '_p_badouble') && extends(argtypes[2], '_p_badouble')) {
      f <- Divide__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_badouble') && extends(argtypes[2], '_p_pdouble')) {
      f <- Divide__SWIG_3; 
    }
    else if (extends(argtypes[1], '_p_badouble') && (is.numeric(argv[[2]]) )) {
      f <- Divide__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && extends(argtypes[2], '_p_badouble')) {
      f <- Divide__SWIG_6; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && (is.numeric(argv[[2]]) )) {
      f <- Divide__SWIG_5; 
    }
    else if ((is.numeric(argv[[1]]) ) && extends(argtypes[2], '_p_badouble')) {
      f <- Divide__SWIG_2; 
    }
    else if ((is.numeric(argv[[1]]) ) && extends(argtypes[2], '_p_pdouble')) {
      f <- Divide__SWIG_4; 
    } else {
        f <- olddivide;
    }
  } else {
      f <- olddivide;
  };
  return(adolc_operator_dispatch(..., f=f))
}

# Dispatch function
# Start of exp

`exp__SWIG_0` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_exp__SWIG_0', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`exp__SWIG_0`, 'returnType') = '_p_adub'
attr(`exp__SWIG_0`, "inputTypes") = c('_p_badouble')
class(`exp__SWIG_0`) = c("SWIGFunction", class('exp__SWIG_0'))

# Start of log

`log__SWIG_0` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_log__SWIG_0', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`log__SWIG_0`, 'returnType') = '_p_adub'
attr(`log__SWIG_0`, "inputTypes") = c('_p_badouble')
class(`log__SWIG_0`) = c("SWIGFunction", class('log__SWIG_0'))

# Start of sqrt

`sqrt__SWIG_0` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_sqrt__SWIG_0', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`sqrt__SWIG_0`, 'returnType') = '_p_adub'
attr(`sqrt__SWIG_0`, "inputTypes") = c('_p_badouble')
class(`sqrt__SWIG_0`) = c("SWIGFunction", class('sqrt__SWIG_0'))

# Start of sin

`sin__SWIG_0` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_sin__SWIG_0', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`sin__SWIG_0`, 'returnType') = '_p_adub'
attr(`sin__SWIG_0`, "inputTypes") = c('_p_badouble')
class(`sin__SWIG_0`) = c("SWIGFunction", class('sin__SWIG_0'))

# Start of cos

`cos__SWIG_0` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_cos__SWIG_0', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`cos__SWIG_0`, 'returnType') = '_p_adub'
attr(`cos__SWIG_0`, "inputTypes") = c('_p_badouble')
class(`cos__SWIG_0`) = c("SWIGFunction", class('cos__SWIG_0'))

# Start of tan

`tan__SWIG_0` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_tan__SWIG_0', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`tan__SWIG_0`, 'returnType') = '_p_adub'
attr(`tan__SWIG_0`, "inputTypes") = c('_p_badouble')
class(`tan__SWIG_0`) = c("SWIGFunction", class('tan__SWIG_0'))

# Start of asin

`asin__SWIG_0` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_asin__SWIG_0', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`asin__SWIG_0`, 'returnType') = '_p_adub'
attr(`asin__SWIG_0`, "inputTypes") = c('_p_badouble')
class(`asin__SWIG_0`) = c("SWIGFunction", class('asin__SWIG_0'))

# Start of acos

`acos__SWIG_0` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_acos__SWIG_0', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`acos__SWIG_0`, 'returnType') = '_p_adub'
attr(`acos__SWIG_0`, "inputTypes") = c('_p_badouble')
class(`acos__SWIG_0`) = c("SWIGFunction", class('acos__SWIG_0'))

# Start of atan

`atan__SWIG_0` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_atan__SWIG_0', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`atan__SWIG_0`, 'returnType') = '_p_adub'
attr(`atan__SWIG_0`, "inputTypes") = c('_p_badouble')
class(`atan__SWIG_0`) = c("SWIGFunction", class('atan__SWIG_0'))

# Start of pow

`pow__SWIG_3` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  
  ;ans = .Call('R_swig_pow__SWIG_3', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`pow__SWIG_3`, 'returnType') = '_p_adub'
attr(`pow__SWIG_3`, "inputTypes") = c('_p_badouble', 'numeric')
class(`pow__SWIG_3`) = c("SWIGFunction", class('pow__SWIG_3'))

# Start of log10

`log10__SWIG_0` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_log10__SWIG_0', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`log10__SWIG_0`, 'returnType') = '_p_adub'
attr(`log10__SWIG_0`, "inputTypes") = c('_p_badouble')
class(`log10__SWIG_0`) = c("SWIGFunction", class('log10__SWIG_0'))

# Start of pow

`pow__SWIG_4` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_pow__SWIG_4', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`pow__SWIG_4`, 'returnType') = '_p_adub'
attr(`pow__SWIG_4`, "inputTypes") = c('_p_badouble', '_p_pdouble')
class(`pow__SWIG_4`) = c("SWIGFunction", class('pow__SWIG_4'))

# Start of sinh

`sinh__SWIG_0` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_sinh__SWIG_0', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`sinh__SWIG_0`, 'returnType') = '_p_adub'
attr(`sinh__SWIG_0`, "inputTypes") = c('_p_badouble')
class(`sinh__SWIG_0`) = c("SWIGFunction", class('sinh__SWIG_0'))

# Start of cosh

`cosh__SWIG_0` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_cosh__SWIG_0', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`cosh__SWIG_0`, 'returnType') = '_p_adub'
attr(`cosh__SWIG_0`, "inputTypes") = c('_p_badouble')
class(`cosh__SWIG_0`) = c("SWIGFunction", class('cosh__SWIG_0'))

# Start of tanh

`tanh__SWIG_0` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_tanh__SWIG_0', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`tanh__SWIG_0`, 'returnType') = '_p_adub'
attr(`tanh__SWIG_0`, "inputTypes") = c('_p_badouble')
class(`tanh__SWIG_0`) = c("SWIGFunction", class('tanh__SWIG_0'))

# Start of fabs

`fabs__SWIG_0` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_fabs__SWIG_0', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`fabs__SWIG_0`, 'returnType') = '_p_adub'
attr(`fabs__SWIG_0`, "inputTypes") = c('_p_badouble')
class(`fabs__SWIG_0`) = c("SWIGFunction", class('fabs__SWIG_0'))

# Start of ceil

`ceil__SWIG_0` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_ceil__SWIG_0', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`ceil__SWIG_0`, 'returnType') = '_p_adub'
attr(`ceil__SWIG_0`, "inputTypes") = c('_p_badouble')
class(`ceil__SWIG_0`) = c("SWIGFunction", class('ceil__SWIG_0'))

# Start of floor

`floor__SWIG_0` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_floor__SWIG_0', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`floor__SWIG_0`, 'returnType') = '_p_adub'
attr(`floor__SWIG_0`, "inputTypes") = c('_p_badouble')
class(`floor__SWIG_0`) = c("SWIGFunction", class('floor__SWIG_0'))

# Start of fmax

`fmax__SWIG_0` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_fmax__SWIG_0', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`fmax__SWIG_0`, 'returnType') = '_p_adub'
attr(`fmax__SWIG_0`, "inputTypes") = c('_p_badouble', '_p_badouble')
class(`fmax__SWIG_0`) = c("SWIGFunction", class('fmax__SWIG_0'))

# Start of fmax

`fmax__SWIG_1` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_fmax__SWIG_1', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`fmax__SWIG_1`, 'returnType') = '_p_adub'
attr(`fmax__SWIG_1`, "inputTypes") = c('numeric', '_p_badouble')
class(`fmax__SWIG_1`) = c("SWIGFunction", class('fmax__SWIG_1'))

# Start of fmax

`fmax__SWIG_2` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  
  ;ans = .Call('R_swig_fmax__SWIG_2', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`fmax__SWIG_2`, 'returnType') = '_p_adub'
attr(`fmax__SWIG_2`, "inputTypes") = c('_p_badouble', 'numeric')
class(`fmax__SWIG_2`) = c("SWIGFunction", class('fmax__SWIG_2'))

# Start of fmin

`fmin__SWIG_0` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_fmin__SWIG_0', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`fmin__SWIG_0`, 'returnType') = '_p_adub'
attr(`fmin__SWIG_0`, "inputTypes") = c('_p_badouble', '_p_badouble')
class(`fmin__SWIG_0`) = c("SWIGFunction", class('fmin__SWIG_0'))

# Start of fmin

`fmin__SWIG_1` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_fmin__SWIG_1', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`fmin__SWIG_1`, 'returnType') = '_p_adub'
attr(`fmin__SWIG_1`, "inputTypes") = c('numeric', '_p_badouble')
class(`fmin__SWIG_1`) = c("SWIGFunction", class('fmin__SWIG_1'))

# Start of fmin

`fmin__SWIG_2` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  
  ;ans = .Call('R_swig_fmin__SWIG_2', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`fmin__SWIG_2`, 'returnType') = '_p_adub'
attr(`fmin__SWIG_2`, "inputTypes") = c('_p_badouble', 'numeric')
class(`fmin__SWIG_2`) = c("SWIGFunction", class('fmin__SWIG_2'))

# Start of fmax

`fmax__SWIG_3` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_fmax__SWIG_3', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`fmax__SWIG_3`, 'returnType') = '_p_adub'
attr(`fmax__SWIG_3`, "inputTypes") = c('_p_pdouble', '_p_badouble')
class(`fmax__SWIG_3`) = c("SWIGFunction", class('fmax__SWIG_3'))

# Start of fmax

`fmax__SWIG_4` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_fmax__SWIG_4', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`fmax__SWIG_4`, 'returnType') = '_p_adub'
attr(`fmax__SWIG_4`, "inputTypes") = c('_p_badouble', '_p_pdouble')
class(`fmax__SWIG_4`) = c("SWIGFunction", class('fmax__SWIG_4'))

# Start of fmin

`fmin__SWIG_3` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_fmin__SWIG_3', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`fmin__SWIG_3`, 'returnType') = '_p_adub'
attr(`fmin__SWIG_3`, "inputTypes") = c('_p_pdouble', '_p_badouble')
class(`fmin__SWIG_3`) = c("SWIGFunction", class('fmin__SWIG_3'))

# Start of fmin

`fmin__SWIG_4` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_fmin__SWIG_4', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`fmin__SWIG_4`, 'returnType') = '_p_adub'
attr(`fmin__SWIG_4`, "inputTypes") = c('_p_badouble', '_p_pdouble')
class(`fmin__SWIG_4`) = c("SWIGFunction", class('fmin__SWIG_4'))

# Start of ldexp

`ldexp__SWIG_0` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  ;ans = .Call('R_swig_ldexp__SWIG_0', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`ldexp__SWIG_0`, 'returnType') = '_p_adub'
attr(`ldexp__SWIG_0`, "inputTypes") = c('_p_badouble', 'integer')
class(`ldexp__SWIG_0`) = c("SWIGFunction", class('ldexp__SWIG_0'))

# Start of exp

`exp__SWIG_1` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_exp__SWIG_1', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`exp__SWIG_1`, 'returnType') = '_p_adub'
attr(`exp__SWIG_1`, "inputTypes") = c('_p_pdouble')
class(`exp__SWIG_1`) = c("SWIGFunction", class('exp__SWIG_1'))

`oldexp` <- `exp`

`exp` <- function(...) {
  argtypes <- get_argtype(...);
  argv <- list(...);
  argc <- length(argtypes);
  if(!isGeneric("copyToC"))
  if (argc == 1) {
      if (!extends(argtypes[1], '_p_badouble') && !extends(argtypes[1], '_p_pdouble')) {
        ans <- oldexp(argv[[1]]);
        return(ans);
      }
  }
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1) {
      f <- exp__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && length(argv[[1]]) == 1) {
      f <- exp__SWIG_1; 
    } else {
      f <- oldexp
    }
  } else {
    stop("cannot find overloaded function for exp with argtypes (",toString(argtypes),")");
  };
  ans <- adolc_dispatch(argv[[1]], oldexp, f);
  ans
}

# Dispatch function
# Start of log

`log__SWIG_1` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_log__SWIG_1', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`log__SWIG_1`, 'returnType') = '_p_adub'
attr(`log__SWIG_1`, "inputTypes") = c('_p_pdouble')
class(`log__SWIG_1`) = c("SWIGFunction", class('log__SWIG_1'))

oldlog <- log

`log` <- function(...) {
  argtypes <- get_argtype(...);
  argv <- list(...);
  argc <- length(argtypes);
  if (argc == 1) {
      if (!extends(argtypes[1], '_p_badouble') && !extends(argtypes[1], '_p_pdouble')) {
          ans <- oldlog(argv[[1]]);
          return(ans);
      }
  }
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1) {
      f <- log__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && length(argv[[1]]) == 1) {
      f <- log__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for log with argtypes (",toString(argtypes),")");
  };
  ans <- adolc_dispatch(argv[[1]], oldlog, f);
  ans
}

# Dispatch function
# Start of sqrt

`sqrt__SWIG_1` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_sqrt__SWIG_1', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`sqrt__SWIG_1`, 'returnType') = '_p_adub'
attr(`sqrt__SWIG_1`, "inputTypes") = c('_p_pdouble')
class(`sqrt__SWIG_1`) = c("SWIGFunction", class('sqrt__SWIG_1'))

oldsqrt <- sqrt

`sqrt` <- function(...) {
  argtypes <- get_argtype(...);
  argv <- list(...);
  argc <- length(argtypes);
  if (argc == 1) {
      if (!extends(argtypes[1], '_p_badouble') && !extends(argtypes[1], '_p_pdouble')) {
          ans <- oldsqrt(argv[[1]]);
          return(ans);
      }
  }
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1) {
      f <- sqrt__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && length(argv[[1]]) == 1) {
      f <- sqrt__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for sqrt with argtypes (",toString(argtypes),")");
  };
  ans <- adolc_dispatch(argv[[1]], oldsqrt, f);
  ans
}

# Dispatch function
# Start of sin

`sin__SWIG_1` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_sin__SWIG_1', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`sin__SWIG_1`, 'returnType') = '_p_adub'
attr(`sin__SWIG_1`, "inputTypes") = c('_p_pdouble')
class(`sin__SWIG_1`) = c("SWIGFunction", class('sin__SWIG_1'))

oldsin <- sin

`sin` <- function(...) {
  argtypes <- get_argtype(...);
  argv <- list(...);
  argc <- length(argtypes);
  if (argc == 1) {
      if (!extends(argtypes[1], '_p_badouble') && !extends(argtypes[1], '_p_pdouble')) {
          ans <- oldsin(argv[[1]]);
          return(ans);
      }
  }
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1) {
      f <- sin__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && length(argv[[1]]) == 1) {
      f <- sin__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for sin with argtypes (",toString(argtypes),")");
  };
  ans <- adolc_dispatch(argv[[1]], oldsin, f);
  ans
}

# Dispatch function
# Start of cos

`cos__SWIG_1` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_cos__SWIG_1', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`cos__SWIG_1`, 'returnType') = '_p_adub'
attr(`cos__SWIG_1`, "inputTypes") = c('_p_pdouble')
class(`cos__SWIG_1`) = c("SWIGFunction", class('cos__SWIG_1'))

oldcos <- cos

`cos` <- function(...) {
  argtypes <- get_argtype(...);
  argv <- list(...);
  argc <- length(argtypes);
  if (argc == 1) {
      if (!extends(argtypes[1], '_p_badouble') && !extends(argtypes[1], '_p_pdouble')) {
          ans <- oldcos(argv[[1]]);
          return(ans);
      }
  }
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1) {
      f <- cos__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && length(argv[[1]]) == 1) {
      f <- cos__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for cos with argtypes (",toString(argtypes),")");
  };
  ans <- adolc_dispatch(argv[[1]], oldcos, f);
  ans
}

# Dispatch function
# Start of tan

`tan__SWIG_1` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_tan__SWIG_1', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`tan__SWIG_1`, 'returnType') = '_p_adub'
attr(`tan__SWIG_1`, "inputTypes") = c('_p_pdouble')
class(`tan__SWIG_1`) = c("SWIGFunction", class('tan__SWIG_1'))

oldtan <- tan

`tan` <- function(...) {
  argtypes <- get_argtype(...);
  argv <- list(...);
  argc <- length(argtypes);
  if (argc == 1) {
      if (!extends(argtypes[1], '_p_badouble') && !extends(argtypes[1], '_p_pdouble')) {
          ans <- oldtan(argv[[1]]);
          return(ans);
      }
  }
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1) {
      f <- tan__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && length(argv[[1]]) == 1) {
      f <- tan__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for tan with argtypes (",toString(argtypes),")");
  };
  ans <- adolc_dispatch(argv[[1]], oldtan, f);
  ans
}

# Dispatch function
# Start of asin

`asin__SWIG_1` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_asin__SWIG_1', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`asin__SWIG_1`, 'returnType') = '_p_adub'
attr(`asin__SWIG_1`, "inputTypes") = c('_p_pdouble')
class(`asin__SWIG_1`) = c("SWIGFunction", class('asin__SWIG_1'))

oldasin <- asin

`asin` <- function(...) {
  argtypes <- get_argtype(...);
  argv <- list(...);
  argc <- length(argtypes);
  if (argc == 1) {
      if (!extends(argtypes[1], '_p_badouble') && !extends(argtypes[1], '_p_pdouble')) {
          ans <- oldasin(argv[[1]]);
          return(ans);
      }
  }
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1) {
      f <- asin__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && length(argv[[1]]) == 1) {
      f <- asin__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for asin with argtypes (",toString(argtypes),")");
  };
  ans <- adolc_dispatch(argv[[1]], oldasin, f);
  ans
}

# Dispatch function
# Start of acos

`acos__SWIG_1` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_acos__SWIG_1', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`acos__SWIG_1`, 'returnType') = '_p_adub'
attr(`acos__SWIG_1`, "inputTypes") = c('_p_pdouble')
class(`acos__SWIG_1`) = c("SWIGFunction", class('acos__SWIG_1'))

oldacos <- acos

`acos` <- function(...) {
  argtypes <- get_argtype(...);
  argv <- list(...);
  argc <- length(argtypes);
  if (argc == 1) {
      if (!extends(argtypes[1], '_p_badouble') && !extends(argtypes[1], '_p_pdouble')) {
          ans <- oldacos(argv[[1]]);
          return(ans);
      }
  }
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1) {
      f <- acos__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && length(argv[[1]]) == 1) {
      f <- acos__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for acos with argtypes (",toString(argtypes),")");
  };
  ans <- adolc_dispatch(argv[[1]], oldacos, f);
  ans
}

# Dispatch function
# Start of atan

`atan__SWIG_1` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_atan__SWIG_1', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`atan__SWIG_1`, 'returnType') = '_p_adub'
attr(`atan__SWIG_1`, "inputTypes") = c('_p_pdouble')
class(`atan__SWIG_1`) = c("SWIGFunction", class('atan__SWIG_1'))

oldatan <- atan

`atan` <- function(...) {
  argtypes <- get_argtype(...);
  argv <- list(...);
  argc <- length(argtypes);
  if (argc == 1) {
      if (!extends(argtypes[1], '_p_badouble') && !extends(argtypes[1], '_p_pdouble')) {
          ans <- oldatan(argv[[1]]);
          return(ans);
      }
  }
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1) {
      f <- atan__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && length(argv[[1]]) == 1) {
      f <- atan__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for atan with argtypes (",toString(argtypes),")");
  };
  ans <- adolc_dispatch(argv[[1]], oldatan, f);
  ans
}

# Dispatch function
# Start of pow

`pow__SWIG_5` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  
  ;ans = .Call('R_swig_pow__SWIG_5', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`pow__SWIG_5`, 'returnType') = '_p_adub'
attr(`pow__SWIG_5`, "inputTypes") = c('_p_pdouble', 'numeric')
class(`pow__SWIG_5`) = c("SWIGFunction", class('pow__SWIG_5'))

`oldcarat` <- `^`

`^` <- function(...) {
    return(pow(...))
}

`pow` <- function(...) {
  argtypes <- get_argtype(...);
  argv <- list(...);
  argc <- length(argtypes);
  if (argc == 2) {
      if (!extends(argtypes[1], '_p_badouble') && !extends(argtypes[1], '_p_pdouble')
          && !extends(argtypes[2], '_p_badouble') && !extends(argtypes[2], '_p_pdouble')) {
          ans <- oldcarat(argv[[1]],argv[[2]]);
          return(ans);
      }
  }
# dispatch functions 6
  if (argc == 2) {
    if (extends(argtypes[1], '_p_badouble') && extends(argtypes[2], '_p_badouble')) {
      f <- pow__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && extends(argtypes[2], '_p_badouble')) {
      f <- pow__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_badouble') && extends(argtypes[2], '_p_pdouble')) {
      f <- pow__SWIG_4; 
    }
    else if (extends(argtypes[1], '_p_badouble') && is.numeric(argv[[2]])) {
      f <- pow__SWIG_3; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && is.numeric(argv[[2]])) {
      f <- pow__SWIG_5; 
    }
    else if (is.numeric(argv[[1]]) && extends(argtypes[2], '_p_badouble')) {
      f <- pow__SWIG_1; 
    } else {
      f <- oldcarat
    }
  } else {
    stop("cannot find overloaded function for pow with argtypes (",toString(argtypes),")");
  };
  return(adolc_operator_dispatch(..., f=f))
}

# Dispatch function
# Start of log10

`log10__SWIG_1` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_log10__SWIG_1', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`log10__SWIG_1`, 'returnType') = '_p_adub'
attr(`log10__SWIG_1`, "inputTypes") = c('_p_pdouble')
class(`log10__SWIG_1`) = c("SWIGFunction", class('log10__SWIG_1'))

`oldlog10` <- `log10`

`log10` <- function(...) {
  argtypes <- get_argtype(...);
  argv <- list(...);
  argc <- length(argtypes);
  if (argc == 1) {
      if (!extends(argtypes[1], '_p_badouble') && !extends(argtypes[1], '_p_pdouble')) {
          ans <- oldlog10(argv[[1]]);
          return(ans);
      }
  }
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1) {
      f <- log10__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && length(argv[[1]]) == 1) {
      f <- log10__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for log10 with argtypes (",toString(argtypes),")");
  };
  ans <- adolc_dispatch(argv[[1]], oldlog10, f);
  ans
}

# Dispatch function
# Start of sinh

`sinh__SWIG_1` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_sinh__SWIG_1', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`sinh__SWIG_1`, 'returnType') = '_p_adub'
attr(`sinh__SWIG_1`, "inputTypes") = c('_p_pdouble')
class(`sinh__SWIG_1`) = c("SWIGFunction", class('sinh__SWIG_1'))

`oldsinh` <- `sinh`

`sinh` <- function(...) {
  argtypes <- get_argtype(...);
  argv <- list(...);
  argc <- length(argtypes);
  if (argc == 1) {
      if (!extends(argtypes[1], '_p_badouble') && !extends(argtypes[1], '_p_pdouble')) {
          ans <- oldsinh(argv[[1]]);
          return(ans);
      }
  }
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1) {
      f <- sinh__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && length(argv[[1]]) == 1) {
      f <- sinh__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for sinh with argtypes (",toString(argtypes),")");
  };
  ans <- adolc_dispatch(argv[[1]], oldsinh, f);
  ans
}

# Dispatch function
# Start of cosh

`cosh__SWIG_1` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_cosh__SWIG_1', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`cosh__SWIG_1`, 'returnType') = '_p_adub'
attr(`cosh__SWIG_1`, "inputTypes") = c('_p_pdouble')
class(`cosh__SWIG_1`) = c("SWIGFunction", class('cosh__SWIG_1'))

`oldcosh` <- `cosh`

`cosh` <- function(...) {
  argtypes <- get_argtype(...);
  argv <- list(...);
  argc <- length(argtypes);
  if (argc == 1) {
      if (!extends(argtypes[1], '_p_badouble') && !extends(argtypes[1], '_p_pdouble')) {
          ans <- oldcosh(argv[[1]]);
          return(ans);
      }
  }
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1) {
      f <- cosh__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && length(argv[[1]]) == 1) {
      f <- cosh__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for cosh with argtypes (",toString(argtypes),")");
  };
  ans <- adolc_dispatch(argv[[1]], oldcosh, f);
  ans
}

# Dispatch function
# Start of tanh

`tanh__SWIG_1` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_tanh__SWIG_1', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`tanh__SWIG_1`, 'returnType') = '_p_adub'
attr(`tanh__SWIG_1`, "inputTypes") = c('_p_pdouble')
class(`tanh__SWIG_1`) = c("SWIGFunction", class('tanh__SWIG_1'))

`oldtanh` <- `tanh`

`tanh` <- function(...) {
  argtypes <- get_argtype(...);
  argv <- list(...);
  argc <- length(argtypes);
  if (argc == 1) {
      if (!extends(argtypes[1], '_p_badouble') && !extends(argtypes[1], '_p_pdouble')) {
          ans <- oldtanh(argv[[1]]);
          return(ans);
      }
  }
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1) {
      f <- tanh__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && length(argv[[1]]) == 1) {
      f <- tanh__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for tanh with argtypes (",toString(argtypes),")");
  };
  ans <- adolc_dispatch(argv[[1]], oldtanh, f);
  ans
}

# Dispatch function
# Start of fabs

`fabs__SWIG_1` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_fabs__SWIG_1', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`fabs__SWIG_1`, 'returnType') = '_p_adub'
attr(`fabs__SWIG_1`, "inputTypes") = c('_p_pdouble')
class(`fabs__SWIG_1`) = c("SWIGFunction", class('fabs__SWIG_1'))

`oldabs` <- `abs`

`abs` <- function(...) {
  argtypes <- get_argtype(...);
  argv <- list(...);
  argc <- length(argtypes);
  if (argc == 1) {
      if (!extends(argtypes[1], '_p_badouble') && !extends(argtypes[1], '_p_pdouble')) {
          ans <- oldabs(argv[[1]]);
          return(ans);
      }
  }
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1) {
      f <- fabs__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && length(argv[[1]]) == 1) {
      f <- fabs__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for fabs with argtypes (",toString(argtypes),")");
  };
  ans <- adolc_dispatch(argv[[1]], oldabs, f);
  ans
}

# Dispatch function
# Start of ceil

`ceil__SWIG_1` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_ceil__SWIG_1', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`ceil__SWIG_1`, 'returnType') = '_p_adub'
attr(`ceil__SWIG_1`, "inputTypes") = c('_p_pdouble')
class(`ceil__SWIG_1`) = c("SWIGFunction", class('ceil__SWIG_1'))

`oldceiling` <- `ceiling`

`ceiling` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  if (argc == 1) {
      if (!extends(argtypes[1], '_p_badouble') && !extends(argtypes[1], '_p_pdouble')) {
          ans <- oldceiling(argv[[1]]);
          return(ans);
      }
  }
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1) {
      f <- ceil__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && length(argv[[1]]) == 1) {
      f <- ceil__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for ceil with argtypes (",toString(argtypes),")");
  };
  ans <- adolc_dispatch(argv[[1]], oldceiling, f);
  ans
}

# Dispatch function
# Start of floor

`floor__SWIG_1` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_floor__SWIG_1', s_arg1, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`floor__SWIG_1`, 'returnType') = '_p_adub'
attr(`floor__SWIG_1`, "inputTypes") = c('_p_pdouble')
class(`floor__SWIG_1`) = c("SWIGFunction", class('floor__SWIG_1'))

`oldfloor` <- `floor`

`floor` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
  if (argc == 1) {
      if (!extends(argtypes[1], '_p_badouble') && !extends(argtypes[1], '_p_pdouble')) {
          ans <- oldfloor(argv[[1]]);
          return(ans);
      }
  }
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1) {
      f <- floor__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && length(argv[[1]]) == 1) {
      f <- floor__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for floor with argtypes (",toString(argtypes),")");
  };
  ans <- adolc_dispatch(argv[[1]], oldfloor, f);
  ans
}

# Dispatch function
# Start of fmax

`fmax__SWIG_5` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_fmax__SWIG_5', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`fmax__SWIG_5`, 'returnType') = '_p_adub'
attr(`fmax__SWIG_5`, "inputTypes") = c('_p_pdouble', '_p_pdouble')
class(`fmax__SWIG_5`) = c("SWIGFunction", class('fmax__SWIG_5'))

# Start of fmax

`fmax__SWIG_6` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_fmax__SWIG_6', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`fmax__SWIG_6`, 'returnType') = '_p_adub'
attr(`fmax__SWIG_6`, "inputTypes") = c('numeric', '_p_pdouble')
class(`fmax__SWIG_6`) = c("SWIGFunction", class('fmax__SWIG_6'))

# Start of fmax

`fmax__SWIG_7` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  
  ;ans = .Call('R_swig_fmax__SWIG_7', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`fmax__SWIG_7`, 'returnType') = '_p_adub'
attr(`fmax__SWIG_7`, "inputTypes") = c('_p_pdouble', 'numeric')
class(`fmax__SWIG_7`) = c("SWIGFunction", class('fmax__SWIG_7'))

`fmax` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 8
  if (argc == 2) {
    if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- fmax__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_pdouble') && length(argv[[2]]) == 1) {
      f <- fmax__SWIG_4; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- fmax__SWIG_3; 
    }
    else if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1 && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- fmax__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_pdouble') && length(argv[[2]]) == 1) {
      f <- fmax__SWIG_5; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && length(argv[[1]]) == 1 && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- fmax__SWIG_7; 
    }
    else if (( is.numeric(argv[[1]]) && length(argv[[1]]) == 1 ) && extends(argtypes[2], '_p_pdouble') && length(argv[[2]]) == 1) {
      f <- fmax__SWIG_6; 
    }
    else if (( is.numeric(argv[[1]]) && length(argv[[1]]) == 1 ) && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- fmax__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for fmax with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of fmin

`fmin__SWIG_5` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_fmin__SWIG_5', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`fmin__SWIG_5`, 'returnType') = '_p_adub'
attr(`fmin__SWIG_5`, "inputTypes") = c('_p_pdouble', '_p_pdouble')
class(`fmin__SWIG_5`) = c("SWIGFunction", class('fmin__SWIG_5'))

# Start of fmin

`fmin__SWIG_6` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  ;ans = .Call('R_swig_fmin__SWIG_6', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`fmin__SWIG_6`, 'returnType') = '_p_adub'
attr(`fmin__SWIG_6`, "inputTypes") = c('numeric', '_p_pdouble')
class(`fmin__SWIG_6`) = c("SWIGFunction", class('fmin__SWIG_6'))

# Start of fmin

`fmin__SWIG_7` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  
  ;ans = .Call('R_swig_fmin__SWIG_7', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`fmin__SWIG_7`, 'returnType') = '_p_adub'
attr(`fmin__SWIG_7`, "inputTypes") = c('_p_pdouble', 'numeric')
class(`fmin__SWIG_7`) = c("SWIGFunction", class('fmin__SWIG_7'))

`fmin` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 8
  if (argc == 2) {
    if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- fmin__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_pdouble') && length(argv[[2]]) == 1) {
      f <- fmin__SWIG_4; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- fmin__SWIG_3; 
    }
    else if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1 && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- fmin__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_pdouble') && length(argv[[2]]) == 1) {
      f <- fmin__SWIG_5; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && length(argv[[1]]) == 1 && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- fmin__SWIG_7; 
    }
    else if (( is.numeric(argv[[1]]) && length(argv[[1]]) == 1 ) && extends(argtypes[2], '_p_pdouble') && length(argv[[2]]) == 1) {
      f <- fmin__SWIG_6; 
    }
    else if (( is.numeric(argv[[1]]) && length(argv[[1]]) == 1 ) && extends(argtypes[2], '_p_badouble') && length(argv[[2]]) == 1) {
      f <- fmin__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for fmin with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of ldexp

`ldexp__SWIG_1` = function(s_arg1, s_arg2)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  ;ans = .Call('R_swig_ldexp__SWIG_1', s_arg1, s_arg2, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`ldexp__SWIG_1`, 'returnType') = '_p_adub'
attr(`ldexp__SWIG_1`, "inputTypes") = c('_p_pdouble', 'integer')
class(`ldexp__SWIG_1`) = c("SWIGFunction", class('ldexp__SWIG_1'))

`ldexp` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_badouble') && length(argv[[1]]) == 1 && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- ldexp__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_pdouble') && length(argv[[1]]) == 1 && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- ldexp__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for ldexp with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of adolc_vec_dot

`adolc_vec_dot` = function(s_arg1, s_arg2, s_arg3)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref") 
  if (inherits(s_arg3, "ExternalReference")) s_arg3 = slot(s_arg3,"ref") 
  ;ans = .Call('R_swig_adolc_vec_dot', s_arg1, s_arg2, s_arg3, PACKAGE='autodiffadolc');
  ans <- new("_p_adub", ref=ans) ;
  
  ans
  
}

attr(`adolc_vec_dot`, 'returnType') = '_p_adub'
attr(`adolc_vec_dot`, "inputTypes") = c('_p_adouble', '_p_adouble', '_p_uint32_t')
class(`adolc_vec_dot`) = c("SWIGFunction", class('adolc_vec_dot'))

# Start of mkparam

`mkparam` = function(pval)
{
  ;ans = .Call('R_swig_mkparam', pval, PACKAGE='autodiffadolc');
  ans <- new("_p_pdouble", ref=ans) ;
  
  ans
  
}

attr(`mkparam`, 'returnType') = '_p_pdouble'
attr(`mkparam`, "inputTypes") = c('numeric')
class(`mkparam`) = c("SWIGFunction", class('mkparam'))

# Start of getparam

`getparam` = function(index)
{
  if (inherits(index, "ExternalReference")) index = slot(index,"ref") 
  ;ans = .Call('R_swig_getparam', index, PACKAGE='autodiffadolc');
  ans <- new("_p_pdouble", ref=ans) ;
  
  ans
  
}

attr(`getparam`, 'returnType') = '_p_pdouble'
attr(`getparam`, "inputTypes") = c('_p_uint32_t')
class(`getparam`) = c("SWIGFunction", class('getparam'))


